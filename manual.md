== CBASIC III 

128/512K COC0-3 DISK EXTENDED {ecb} COMPILER & program EDITING SYSTEM 

*Revision A* 

*CER-COMP* 
5566 RICOCHET AVE. 
LAS VEGAS, NEVADA 89110 

( 702 ) 452-0632 

COPYRIGHT (C) 1987  BY WILLIAM E. VERGONA 

ALL RIGHTS RESERVED 

== Limited License To Users 


Cer-Comp grants you, the owner and original purchaser of 
{CB}, a limited license for incorporating {CB} to create 
your own marketed software products as long as they do not include 
the use of the HIRES Screen package generated by the compiler 
using the "HIRES" command. If you wish to use this Proprietary 
driver in a marketed software product, the author must agree to abide by all of the following conditions: 

1. No reproduction of this documentation is permitted. 
2. Author or publisher must supply Cer-Comp with a complete copy 
of the finished software package wit hin 30 days of first 
publication. 
3. The Author or publisher must pay a royalty of Five-Dollars 
($5. 00) for each copy of the program produced, to be paid on a 
quarterly basis (three month). 
Failure to comply with all of the preceding conditions set 
forth will result in immediate revocation of limited license and 
production shall be ceased until all conditions are met to the 
satisfaction of Cer-Comp. Cer-Comp would, of course appreciate 
the opportunity to publish any program you develope which 
incorporates the {CB} compiler. 

=== Disclaimer 

A great deal of time and effort was used in the creation of 
this program, and great care was taken to insure that this program 
will perform and operate as advertised. If you find a "bug" or 
problem wit h this program, please notify us. We will do our best 
to correct it, but we do not guarantee to do so. Cer-Comp does 
not warrant the suitability or functioning of its products for any 
particular user and will not be responsible for damages incidental 
to its use or misuse. This warranty is in lieu of all other 
warranties either expressed or implied. Cer-Comp assumes no 
responsibility for the consequences of the use or misuse of this 
or any other software and documentation. 

Cer-Comp reserves the right to make changes and improvements 
without prior notice. New revisions will be made available on an 
exchange basis for a fee of $15.00 to cover the cost of 
reproduction, manual updates (if required) and return postage. 

<<<

Text Layout:: Ruby Gem - ASCIIDOCTOR-PDF

Revision: 1.0 (DRAFT 10/26/2019)

Sources:: GITHUB 

Editor:: Pete Willard

Date:: October 2019




[NOTE]
In this revised version of the document, all references to fees and obtaining support are deprecated.

<<<

== Introduction 

[.lead]
{CB} is a complete programming system designed for use on a 128/512K Color Computer 3 with at least one Disk drive. It is completely written in fast efficient Machine Language to take full advantage of the power and flexibility of the 6809E Micro Processor and the *GIME* _(Graphics Interrupt Memory Enhancement)_ chip in the Color Computer 3. 

It will take full advantage of the 512K of address space available in the Color Computer if 512K is installed, during program Creation, Editing and Compilation. It also provides the user with options to make full use of the 512K available during program run-time.

The Editor contained in {CB} is used to Create and/or Edit programs for the {CB} compiler. It is a full featured editor, with functions designed specifically for writing and editing Basic programs. It has built in block Move and Copy functions with automatic program renumbering, easy to use commands for inserting, deleting and over typing on existing program lines. 

It is also used for Loading, Saving, Appending and Killing disk files, as well as displaying a disk Directory. Once a program is ready to be compiled, the Editor is issued a command to compile the program, it then calls the compiler portion of the program. 
 
The {CB} compiler is an optimizing two-pass Basic compiler which converts programs written in Basic to pure 6809 Machine Language programs which are written directly to disk in a `LOADM` compatible format. The compiler generated program can be run as a stand-alone RAM based program which may be used without any run-time package. 
 
A built in Linker/Editor automatically selects subroutines from the internal run-time library and inserts one and only one copy of subroutines required directly into the object program. This eliminates the need for cumbersome "run-time" packages that must be loaded separately and usually contain many extra functions not required by the run-time program. 
 
Depending on the specific program, {CB} can produce programs which may reflect a 5 to 1000 times speed improvement over an interpreter. Since {CB} also contains statements for supporting Disk and Tape I/O, Hi-Res Graphics and Enhanced Screen formats, it is well suited for a wide range of system programming applications. 

=== Scope And References 

[.lead]
This manual is written to acquaint the user with the features 
of the {CB} Editor/Compiler. It should be noted by the user 
that this is a complex operating system and cannot be fully 
understood with a single reading. 

It will require the user many 
hours of study, usage and experimentation to fully understand the 
power of this invaluable tool. 

It is assumed that the user has a previous knowledge of the 
Basic programming Language, as well as a basic understanding of 
the Tape & Disk Systems of the Color Computer. If this is not the 
case, you may wish to read the manuals listed below prior to using 
this manual. 

This manual is intended as a reference, and is 
concerned only with describing the additional functions, 
statements and capabilities provided by the {CB} 
Editor/Compiler.  It is not the intent or within the scope of this 
manual to teach the user how to write programs in the Basic or Assembly language. 

Radio Shack:: "Color Computer 3 EXTENDED Basic" 

Radio Shack:: "Color computer Disk System: Owners Manual"

Radio Shack:: "TRS-80 Color Computer Assembly Language programming" 

[NOTE]
Additional manuals are available from Radio Shack and other sources which describe the Basic programming Language in general. 


==== Additional Keyboard Characters 

{CB} has several keyboard characters that are not normally available on the Coco. Some of the additional keys 
generate the same characters as the arrow & shift keys did previously. The reason for this is, when editing, which uses the arrow and clear keys, you can still generate these key codes if necessary. 

.New Keyboard Characters 
[width="80%",align="center"]
[cols="30,20,20,30"frame=none,grid=none]
|===
| *New Combination* | *Output* |  *Value* |*Legacy Keys*

| kbd:[CLEAR,0] ^| `\`     ^| $5C |kbd:[SHIFT,CLEAR]
| kbd:[CLEAR,1] ^| `{bar}` ^| $7C |*n/a
| kbd:[CLEAR,2] ^| `~`     ^| $7E |*n/a        
| kbd:[CLEAR,3] ^| `[`     ^| $5B |kbd:[SHIFT,{down}]
| kbd:[CLEAR,4] ^| `]`     ^| $5D |kbd:[SHIFT,{right}]
| kbd:[CLEAR,5] ^| `^`     ^| $5E |kbd:[{up}]
| kbd:[CLEAR,6] ^| `_`     ^| $5F |kbd:[SHIFT,{up}]
| kbd:[CLEAR,7] ^| `'`     ^| $60 |*n/a
| kbd:[CLEAR,8] ^| `{`     ^| $7B |*n/a
| kbd:[CLEAR,9] ^| `}`     ^| $7D |*n/a
|===


=== Startup Procedures 

{CB} is a 6809 machine language program written for use 
on a Color Computer III with at least 128K of RAM. To Execute the 
program, place the original disk in your disk drive and enter 

`LOADM"CBASIC3"` kbd:[ENTER]

This will cause the program to be loaded 
into the computers memory and automatically executed. The program 
will then display an introduction message followed by the amount 
of free memory available and the `READY` prompt. 

You are now ready to load a program or enter commands to the {CB} Text 
Editor. If an error should occur while trying to load the 
program, check the disk directory to make sure you are using the 
same file name as listed in the disk directory. Also make sure 
you are using the Original disk and not a backup copy. 

=== Backup Procedures 

Make a backup copy using the `BACKUP` command and put the 
backup disk in a safe place. Always use the Original disk to `LOAD` 
and Execute the program. Should the original disk fail, use the 
"Backup Disk" you created to restore the original disk. The 
original disk comes recorded on both sides for your added 
protection against a disk failure. The only way the original disk 
should be written to is with a `BACKUP` command using the backup 
disk you created to restore the original. 

If you are unable to restore the Original disk due to 
physical damage etc., return the Original disk only, to Cer-Comp 
with a check or M.0. in the amount of $2.50. We will replace the 
disk and ship it back to you within 1 working day. 

=== Ramdisk & 512k 

If your COC0-3 has 512K of memory installed, {CB} will 
automatically install 2 RAMDISK's as drives 2 & 3. These RAMDISK's 
can be used the same as normal disk drives only they are much 
faster. You can use then to: save temporary files or Compile 
programs to just like a normal disk drive. The RAMDISK storage 
format is compatible with our own RAMDISK program available 
separately for only $19.95. When using our RAMDISK, files stored 
in them will be available when you enter or leave {CB} as well 
as any of our disk programs. 

== Text Editing Commands 

*TEXT EDITOR* 

=== Conventions Used in the Manual

`\` :: The "Backslash"  is the character displayed when the kbd:[SHIFT,@] keys are 
depressed as a delimiter for the `SEARCH` & `REPLACE` commands. Also see editor command summary. 

*()* :: When items are enclosed within these characters are required by 
that command to perform correctly. 

*[]* :: When items are enclosed within these characters are considered to be  
optional, when used they must also be in the required order. 

*<>* :: When items are enclosed within these characters they are comments. 

kbd:[ENTER] :: is used to denote an kbd:[ENTER] key press and is used to 
signify the completion of a line entry. 

kbd:[-] :: The "Dash" is used as a delimiter between line numbers. 

kbd:[{left}] :: The Left arrow is recognized as a Backspace. 

kbd:[BREAK] :: This key is used to regain control at any time and will return to 
the `READY` prompt.  If kbd:[BREAK] is depressed during a line entry or 
edit, any changes or recent entries will be ignored. 

[NOTE]
Any key can be used to stop the present output and it will be 
resumed upon entry of any key but kbd:[BREAK]. 

[TIP]
All commands can be abbreviated by using the first two 
characters of the command followed by its normal paRAMeters. 
 

==== Line Entry

Enter a line number, followed by a space and text ending with 
the kbd:[ENTER] key. 

The line buffer is preset to 255 characters.  The cursor will not advance past the last character position, nor will it backspace beyond the first character position. Ten characters before the end of line a medium tone beep will be heard and a higher tone beep will be heard at the end of the line. Any time during line entry if an invalid control character key is entered a double low tone beep will be heard.

Entry of a line number over four digits will result in only 
the last four digits being accepted. 

Entry of a line number followed by kbd:[ENTER] will delete the 
line previously entered using that line number. 

Entry of a new line using a previously entered line number 
will cause that line to be replaced with the new line. 

Entry of a line with a line number between two previously 
entered line numbers will insert the new line between them. 

==== Printing

Any time the printer is requested for an operation the status of the printer is checked for ready. If the printer is found to be in a *NOT READY CONDITION*, a message to that effect will be displayed and the program will wait for any key on the keyboard to be pressed, except the kbd:[BREAK] key. If the kbd:[BREAK] key is depressed the printer output will be aborted. This will al low those users not having a printer to abort an accidental printer request and not hang up the system.


==== LIST 


*SYNTAX* : `LIST` _[line number] (-) [line number]_

Entry without line numbers will list the entire file. Entry with a single line number will list only that line. Entry of two line numbers will list from the first line number to the second one. This is very similar the the {ecb} `LIST` function.


Example :: `LIST 100-300` kbd:[ENTER] 

==== RENUMBER  

Causes the Basic file to be renumbered.  If no increment is specified a value of 10 is used. If a starting line # is not 
specified the increment value is used. If the lines exceed 9999 before the end of file, the increment is automatically decreased. The re-numbering is repeated until a workable value is reached.

Example :: `RENUMBER 5 100` kbd:[ENTER] 

_This will Re-sequence the line numbers in the file and increment each line number by 5, beginning with 100._

==== DELETE 

*Syntax* : `DELETE` _<begin line#>-<end line#>_ 

The delete function allows large segments of the text buffer to be removed without having to enter each line number to be deleted. If no line specifications are entered the user will be prompted as to whether the entire contents of the buffer are to be deleted. This is mainly to prevent the accidental deletion of the text buffer contents.


Example :: `DELETE 100-199` kbd:[ENTER] 

_Remove all the lines in the text buffer between and including lines 100 thru 199._

==== SEARCH 

*Syntax* : `SEARCH` _[line #](-)[line #]\[string]\_

Searches for all occurrences of the string between the delimiters kbd:[SHIFT,@]. All the lines containing the specified string will be displayed. If the optional start & stop lines is omitted the search will begin at the beginning of the file to the end of the file. If only the starting line # is specified, it will search to the end of file.

Example :: `SEARCH 100-199 \TEST\` 

_List all the lines containing the string 'TEXT' between lines 100 thru 199._

==== REPLACE (RP)

*Syntax* : `RPLACE` _[line #](-)[line #] \[string)\[string]\_

This function will replace all occurrences of the first string between delimiters kbd:[SHIFT,@] with the second string. If 
the optional line #'s are not specified then the entire file will be used.  If only the starting line # is specified then the replace will be from the line # to  the end of file. If both start & end line #'s are specified then only the lines including the range be used. 

Example :: `RPLACE 100-999 \TEST\TESTER\` 

_This would tell the editor to replace all occurrences of 'TEST' between lines 100 and 999 with 'TESTER'._


==== LINE EDIT 

*Syntax* : `LEDIT` _[line #]_ 

Causes the line number specified to be displayed and the 
cursor to be positioned under the first character of the line. The 
*EDIT* mode is then entered, see <<EDITOR KEYS>> under <<AEDIT>>. 

Example :: `LEDIT 110` kbd:[ENTER] 

_Edit line number 100 using the edit functions._

==== AUTO EDIT 

*Syntax* : `AEDIT` _[line #]_ 

Causes the automatic edit mode to be entered, if the starting line # is specified the edit function will continue from that line until the end of the file or a until a cancel edit operation character is entered. All the edit commands are the same as `LEDIT` (line edit).

If no change is required on a line press the kbd:[{down}]  key and the next line will be brought up for editing. If the line is to be deleted, just enter kbd:[SHIFT,CLEAR].

Example :: `AEDIT 100` kbd:[ENTER] 

_Begin automatic line editing starting at line 100._

===== Editor Keys 

.*EDIT FUNCTION KEYS*  
[width="60%",align="center"]
[cols="2",frame=none,grid=none]
|=== 
|FUNCTION                           | DEPRESS 

|MOVE CURSOR RIGHT                  | kbd:[{right}] 
|MOVE CURSOR RIGHT  l WORD          | kbd:[CLEAR] 
|MOVE CURSOR LEFT (backspace)       | kbd:[{left}]  
|INSERT SINGLE SPACE                | kbd:[SHIFT,{up}]  
|MULTIPLE CHARACTER INSERT on/off   | kbd:[SHIFT,@] 
|DELETE CHARACTER                   | kbd:[SHIFT,{down}]  
|MOVE CURSOR TO END OF LINE         | kbd:[SHIFT,{right}]  
|MOVE CURSOR TO BEGIN OF LINE       | kbd:[SHIFT,{left}]  
|GOTO NEXT SEQUENTIAL LINE          | kbd:[{down}] 
|GOTO PREVIOUS LINE                 | kbd:[{up}] 
|END LINE AT CURSOR POSITION        | kbd:[SHIFT,CLEAR]  
|REPLACE OLD LINE WITH NEW          | kbd:[ENTER] 
|EXIT FROM EDIT MODE                | kbd:[BREAK] 
|===

==== COPY 

*Syntax* : `COPY` _(from line#)-(to line#) (new location line#)_

The copy function allows portion of the current text buffer  to be copied to another portion of the file. The lines included in the specifications "from" and "to" are copied to the new location line following the destination line. 

The portion of the file copied is left intact and the file is automatically renumbered upon completion of the copy. 

Example ::  `COPY 1100-1345 100` kbd:[ENTER]

_This would place a copy of the lines from 1100 thru 1345 following line 100._

==== MOVE 

*Syntax* : `MOVE` _(from line#)-(to line#) (new location line#)_ 

The *MOVE* command works almost exactly the same as the *COPY* 
command only the original lines _from-to_ are removed from the 
file after they are copied to the new location. The file is 
renumbered the same as in the copy function. 

Example :: `MOVE 1100-1345 100` kbd:[ENTER]

_This would move the lines from 1100 thru 1345 to the next line following line 100._

==== Automatic Line Numbering

*Syntax*: `AUTO` _[ 1 digit increment value ] [ line # ]_

Causes the computer to type sequential line numbers 
incremented by the specified 1 digit value. If not specified the 
line # will be incremented by 10. Also an optional starting line # 
can be specified. This is used for entering sequential text lines 
without having to specify line numbers, they will automatically 
be typed after each line is entered. 

Example : `AUTO 100` kbd:[ENTER]

_Enter auto line typing beginning with line "100" with a default increment value of "10"._

==== SIZE 

_MEMORY SIZE COMMAND_

*Syntax*: `SIZE` kbd:[ENTER] 

Example :: Responds with: 

Displays the amount of memory in use, followed by the amount of memory remaining in the text buffer.

==== PRINTER

*Syntax* : `PRINTER` [command line]

Specifies that the next output operation will be output to 
the printer. Another command may follow the *PRINTER* command for 
ease of use. If you want a printed listing of the compiled 
program, this command must be used prior to the `{CB}` command, `PR {CB}` 

Example :: `PRINTER NLINE LIST` kbd:[ENTER]

_This would tell the editor to list the file to the printer with no line numbers._

==== EXIT 

*Syntax* : `EXIT` kbd:[ENTER] 

_Causes control to return to `BASIC`. Once you exit {CB} you cannot return or re-execute the program, it must be re-loaded from disk_

==== NEW

*Syntax* : `NEW` kbd:[ENTER] 

Causes the memory file buffer to be cleared and all pointers 
reset to the cold start condition. All previously entered 
information will be lost. You will be prompted with the message 
*ARE YOU SURE?*, if you enter any character other than a *"Y"* the 
command will be ignored. 

==== BRATE 

_PRINTER BAUD RATE_

*Syntax* : `BRATE` _<value>_  

_Set Printer baud rate_ 

This command will allow users having printers that run at 
baud rates other than 600 baud, to change printer rates while 
under `{CB}` control. The baud rates are set by entering a 
value from zero thru seven (0-6) to represent the desired rate. 
The rate values are as follows: 

[width="50%",align="center"]
[cols="50,50",frame=none,grid=none]
|===
| Value | Baud Rate

|0  |110
|1  |300
|2  |600
|3  |1200
|4  |2400
|5  |4800
|6  |9600
|===

Example: `BRATE 5` kbd:[ENTER] +
_Set baud rate to 4800 baud_ 

==== LF

_PRINTER LINE FEED COMMAND_

*Syntax* `LF` kbd:[ENTER] +
_Allow line feed character output_ 

This function is for those users having printers that do not 
automatically line feed upon receipt of a carriage return 
character. Normally line feed character output is inhibited, once 
this command is entered they will be output for each line and 
cannot be inhibited once enabled. 

==== RD (Key Repeat)

_AUTOMATIC KEY REPEAT DELAY COMMAND_

*Syntax* : `RD` <value> 

This command allows the user to program whether or not to 
allow the keyboard keys to automatically repeat and if so, how 
fast or often it is repeated. If the command is followed by a 
value of "0" then automatic repeat will be disabled entirely. If 
a value between 1 and 47 follows, that value will be used to 
determine how fast the keys will repeat. 

The smaller the number the faster the key will repeat. The default value is around 15 
which causes a repeat at a reasonable rate. Each individual will 
have to set this to their own personal taste. The del ay from the 
first time a key is pressed until it begins to repeat is 
approximately 2 seconds and is not adjustable. 

Example::  `RD 5`  kbd:[ENTER] +
             _Set Repeat Delay to 5 (fast)_ +
           `RD 0`  kbd:[ENTER] + 
             _Turn Auto Repeat off_

==== SW (Screen Width)

_SCREEN WIDTH - Set Characters per line_ 

*Syntax* : `SW` _<value>_ 

The SW command allows the user to set the number of 
characters displayed per line on the Screen. This can be varied 
from 32 to 80 characters per line in defined steps. The default 
display comes up in 80 character mode at program startup time, but 
can be changed to one of 8 different formats. The following 
values correspond to the number of display characters per line. 

[width="75%",align="center"]
[cols="25,50,25,50",frame=none,grid=none]
|===
|Value    |Width      |Value   |Width

|1      |32 (192)   |5      |32 (225) 
|2      |40 (192)   |6      |40 (225) 
|3      |64 (192)   |7      |64 (225) 
|4      |80 (192)   |8      |80 (225) 
|===

The numbers in the parenthesis represent the number of 
vertical scan lines used on t he display. The 225 mode gives an 
extra pixel width between lines so that the descender on 
characters will not appear to touch the tops of the letters on the 
line below. If your TV or Monitor can't handle the extra lines, 
select one of the 192 line modes. 

Example : +
`SW 8` kbd:[ENTER] + 
_Set width to 80 chars/line (225)_ +
`SW 3` kbd:[ENTER] + 
_Set width to 64 chars/line (192)_ 

==== SCREEN

_COLOR SELECT_

*Syntax* : `SCREEN` _<Foreground> <Background>_

This command allows the user to select the Foreground 
(character color) and Background colors for the display. The 
program defaults to Black characters on a Buff Background (0,63). 
You can select any color you like from 0 to 63, see page 297 of 
your COC0-3 manual for some sample color values. 

Example : +
`SCREEN 63 0` kbd:[ENTER] +
_BUff chars/Black Background_ +
`SCREEN 18 O` kbd:[ENTER] +  
_Green chars/Black Background_

==== CC 

_CHANGE COLOR/MONOCHROME MODE_

*Syntax* : `CC` kbd:[ENTER] 

This command allows the user to force the computer to suppress 
the color output to the display or to Enable the color output. By 
default the program automatically select Monochrome mode when 
first started up. 

Example :: `CC` kbd:[ENTER] +
 _Change screen color_

=== Text Editor I/O Commands 

==== SAVE

_DISK FILE SAVE COMMAND_

*Syntax* : `SAVE` _[file name.extension:disk drive]_

The SAVE command writes the file with the specified file name 
to disk. If no disk drive/id is entered a default drive of "0" is 
assumed. The file extension is assumed to be a *CBA* file if not 
specified. The entire file is saved from the text buffer. If the 
output file is already in use from a previous file that was larger 
than the text buffer an error message of *"OUTPUT FILE ALREADY IN 
USER"* will be displayed. 

Example: +
`SAVE BIOIA.ASM` +
`SAVE BIOIA: 3` 

==== LOAD

_DISK FILE LOAD COMMAND_

*Syntax* : `LOAD` _[file name.extension:disk drive]_

The LOAD command opens a disk file for input to the text 
buffer, if line numbers are not included in the text file they 
will be added. If the file is larger than the available text 
buffer the user will be prompted for an output file drive and 
name. 

If an output file cannot be opened the input file will be 
closed and only that portion of the file will be accessible for 
editing. When a duplicate output file is encountered it is 
automatically removed by the {ecb} disk system so be aware when 
specifying file names. 

Example :: `LOAD BIOIA:3` +
_Open the file BIOIA on drive #3 for input and read it into the available text buffer._

==== APPEND

_DISK FILE APPEND COMMAND_

*Syntax* : `APPEND` _[file name.extension:disk drive]_

The `APPEND` command adds the file to the end of the present 
memory file. The Disk drive and file extension options are the 
same as the `LOAD` command. If the input file is already in use an 
appropriate error message will be displayed. 

Example :: `APPEND BIOIA:3` +
_Open the file BIOIA on drive #3 for input and append it into the available text buffer._


==== DRIVE 

*Syntax* : `DRIVE` _<number>_ 

The Drive command allows you to specify a default disk drive 
for Disk commands. The value can be in the range of 0 to 65, this 
allows Hard Disk users to use up to a 10 Meg. drive. 

Example :: `DRIVE 3`

==== DIR

*Syntax* : `DIR` _<drive number>_ 

The `DIR` command allows the user to examine the directory on a 
specified disk drive. If the drive number is not specified a 
default drive of "0" is assumed. The disk directory is displayed 
the same as if the command had been executed from basic and the 
kbd:[SHIFT,@] must be used to pause the display during this command. 

Example :: `DIR 2` +
_This would list the entire directory from the disk on drive number two._


==== KILL

*Syntax* : `KILL` +
_[file name. extension:disk drive]_

The `KILL` command allows you to remove unwanted files from the 
specified disk. It works basically the same as the {ecb} "KILL" 
command except the file extension will automatically default to a 
*"CBA"* extension. 

If not specified the disk drive will automatically default to drive "0". Any errors will be reported the same as normal disk errors. 

Example :: `KILL BIOIA.TXT:3` + 
_Remove the file BIOIA.TXT from the disk on drive number 3._

==== CBASIC

_CBASIC COMPILER COMMAND_

*Syntax* : `CBASIC` _[file name.extension:disk drive]_

The `CBASIC` command is used to compile the Basic program in 
memory. Optionally a disk file name can be specified for the 
compiled object program. If no file name is specified a program 
will not be created, this can be useful for testing for
syntax errors or for generating a printed listing only. 

Example :: `PR CBASIC BIOIA:l` +
_This command string would enable output to the printer `PR` and then call the `CBASIC` compiler, the program would be compiled with the object code file being written to a file labeled "BIOIA" on drive #1, the extension default would be `.BIN`._

<<<
== The {cb} Program Structure

A {CB} program consists of a series of "source lines". A 
source l ine consists of a line number followed by one or more 
{CB} Statements. If the source line contains more than one 
statement a colon `:` character is used to separate the statements. 
A source line may contain up to 250 characters. 

Line numbers are decimal numbers which are up to "four" digits and positive. These must appear sequentially in a program 
and may not be duplicated. When converting a {ecb} program which has line numbers greater than 9999, renumber the program 
using {ecb} before saving the program to disk in ASCII format. 

[TIP]
Spaces in {CB} statements are not required, however they may be used to improve readability (except when used in string 
constants or following variable names that precede a command).  Unlike interpreters, REMark statements and spaces do not affect 
program size or speed and may be used generously to improve program readability and documentation.

Example of program structure: 


[source, bbcbasic]
----
100 PRINT "THIS program FINDS THE AVERAGE OF A SERIES OF NUMBERS" 
110 INPUT "HOW MANY NUMBERS "; N : T=0 
120 FOR I=1 TO N: INPUT "NEXT NUMBER";I : T=T+1 :NEXT I 
130 PRINT:PRINT:PRINT "AVERAGE IS";T/N 
140 PRINT "DO YOU WANT TO CONTINUE":INPUT A$ 
150 IF A$="YES" THEN 100 ELSE END 
----

As you can see in the sample program, the syntax of a {CB} program is very similar to that of the {ecb} 
interpreter. Most of the {CB} statements are identical in format to {ecb}. Many programs may be written with the 
interpreter for testing and debugging, then saved to disk in ASCII format, loaded into {CB} and compiled. Most of the syntax 
differences between {CB} and {ecb} can be used in the interpreter for testing and debugging. However, there are some 
syntax formats in {ecb} that cannot be used in {CB}. 

These minor differences will become apparent as you use {CB}, and should not pose much of a problem in converting existing Color 
Basic programs. 

== Arithmetic Operations

=== Numbers 

[.lead]
{CB}'s numeric data type is internally represented as 16
bit two's compliment integers (2 bytes). This permits an
equivalent decimal number range from +32767 to -32768. This data
representation is quite natural to the 6809's machine instruction
set which allows {CB} to produce extremely fast and compact
machine code.

Because the compiler supports boolean operations, unsigned 16
bit binary numbers may also be used for many functions. The range
for these are: 0 to +65535. These numbers are used for
referencing memory addresses in many cases.

{CB} programs may include numeric constants in either
decimal or hexadecimal notation. In the latter case a dollar sign
"$" or the characters "&H" must precede the hex value or a pound
sign "#" to represent the logical compliment (1REMs compliment or
boolean NOT).

Examples of LEGAL numeric constants:

[width="75%",align="center"]
[cols="25,75",frame=none,grid=none]
|===
|200    | Normal Positive number
|-5000  | Negative Number
|$100   | Hexadecimal notation
|&H1000 | Hexadecimal Notation
|#1     | Inverse of 1
|#$5000 | Inverse of Hexadecimal 5000
|===

Examples of ILLEGAL numbers:

[width="75%",align="center"]
[cols="25,75"]
[frame=none,grid=none]
|===
|9.99       |Fraction not allowed except in CIRCLE statement
|100000     |Number too large
|+20        |Plus sign not allowed, assumed if not minus
| -1 $FFFF #0 65635 &HFFFF |Because binary numbers are represented in either unsigned or
2's compliment form, as well as the differences between hex and
decimal notation of identical numbers, all these number
constants have the same binary value.
|===



=== Numeric Operators, Functions and Variables

Legal numeric variable names in {cb} consist of a one or
two letter name or a single letter and a digit 0-9. Variable
names can be longer than two letters if desired but only the first
two letters or characters are used for the name. The following
are legal variable names:

[width="80%",align="center"]
[cols="25,75"]
[frame=none,grid=none]
|===
|`x`      | Single Letter Lower Case 
|`N`      | Single Letter Capitalized
|`xx`     | Letters Lower Case
|`ZX`     | Letters Capitalized
|`r2`     | Letter + #, Lower Case
|`A0`     | Letter + #, Capitalized
|`ZIP`    | More than 2 letters, only 1st two are used. IE; `ZI`)
|===

If declared in a `DIM` statement, numeric variables may be
arrays of one or two dimensions. The maximum subscript size is
32767, therefore the largest one-dimensional array would require
65534 bytes of memory (_which is too big to actually be used in
Color Computer_). Subscripts begin at 0 (_BASE 0 subscripting_).

When referencing subscripted variables, the subscripts may be
numeric constants, variables, or expressions as long as the
evaluated results is a positive number from 0 to 32767. {cb}
does not perform run-time subscript error checking for over range
errors which would cost considerably in terms of program size and
speed.  

Two dimensional numeric arrays may be defined and used for
a 1 dimensional access which is much faster than a 2 dimension
access. If you had the array `A(30,100)`, you could access it as if
it was `A(3000)`.

References to two dimensional arrays with less than 255
elements or rows will use the internal 8 by 8 bit multiply
instruction for indexing. Numeric arrays with over 255 elements
will use a fast 16 by 16 bit multiply to index into the array.
Obviously, the smaller two dimensional and one dimensional array
will have a faster access than a two dimensional array with over
255 elements or rows.

Examples of legal subscripts::  `N(M)   A(l200)   Z2(CX)   Z4(N,MZ)` + 
    `H(N*(A/B),X+2) + R4(N*AZ+K)` 

[TIP]
{cb} considers a simple variable with the same name as an
array to be the first element of an array. 

For example :: If there is an array `A(20,20)` using the variable name `A` without any
subscript is equivalent to using `A(0,0)`.

Each numeric variable or element of an array is assigned two
bytes of RAM for run-time storage.

=== Arithmetic Operators

The five legal operators for arithmetic are:

[width="80%",align="center"]
[cols="10,90"]
[frame=none,grid=none]
|===
|+          |Add
|-          |Subtract   
|*          |Multiply
|/          |Divide
|-          |Negative number (UNARY)
|===

There are also four boolean operators:

[width="80%",align="center"]
[cols="25,75"]
[frame=none,grid=none]
|===
|& or AND       |Logical AND
|! or OR        |Logical OR   
|%              |Exclusive OR
|#              |Logical NOT aka Complement or Invert (UNARY)
|===

[NOTE]
For those who see UNARY and say "huh?"  It means, a operation that does not require 2 or more parts.  "2+2=4" is not a unary operation because there are 2 parts and a result while "-2" is a unary operation because it makes a value "negative".

All of the above operators may be mixed in arithmetic expressions. The boolean operators, operate in a bit-by-bit manner across all 16 bits of the numeric variable.


The order of operation determines in which order {cb} processes expressions. The compiler will convert arithmetic
expressions to an internal form during compilation, and rearrange expressions following the order of operations. In this way
{cb} may produce machine instructions which are shortest and fastest. Expressions are evaluated in the following order:

* Numeric Functions
* Unary Negative and Not
* Multiplication, Division
* Addition, Subtraction
* Relational tests `<`,`>`,`=`, `<=`,`>=`,`<>`
* Boolean operations `AND`,`OR`,`&`, `!`,`%`

[NOTE]
Parenthesis may be used to alter the normal order of evaluation where required.

Some examples of legal expressions:: `A*B(N,M+4)` +
        `$200+ZX` + 
        `A&BIC*D/F+(H+(J*2)&$FF00)` +
        `N+A(Z)/VAL("FOUR")` +
        `(C<>D AND A$=B$)` OR `(C>D AND A$=D$)`

<<< 
=== Arithmetic Functions
==== ABS(expr) 
The absolute value of the numeric expression (-324 = 324).  The absolute value of a real number is the number of units from 0 the number is. The absolute value of 7 for example is 7 becasue it is that many units away from zero. The absolute value of -7 however is 7. So it in a way gets rid of the negative.

Example :: `abs(5) is 5` +
           `abs(-5) is 5`


==== INT(expr)
Converts the numeric expression to an integer (For {ecb} testing)

==== RND(expr)
Returns a random integer between l and the specified expression value (1-32767).

==== PEEK(expr)
Returns the contents of the memory location determined by the results of the numeric expression.

==== DPEEK(expr)
Returns the 16 bit value from the two consecutive memory locations determined by the results of the numeric expression.

==== POS(expr)
Returns the current character position of the specified device number (O=screen, 2=printer, 3=RS-232 port).

==== POS@
Returns the current PRINT@ location on the screen.

==== SWAP*(expr) 
Byte swap of the results of the numeric expression. High order & low order bytes are exchanged.

==== SGN*(expr) 
Returns a value indicating whether the expression is positive (+l), negative (-1) or zero (0).

==== TIMER
Returns the contents or allows setting the timer 0-65535.
 TIMER=(expr)
 Var=TIMER`

==== VARPTR*(var)
Returns the absolute memory address for a variable.

==== OVEREM
Returns the overflow results of a multiply or the remainder of a divide function. Valid immediately after a multiply or divide only.

=== Arithmetic Errors
Arithmetic operations may produce several types of errors
which may be detected and processed. Addition and Subtraction may
result in a carry or borrow condition. Either one will result in
the Carry bit of the MPU's condition code register being set. The
`ON OVR` and `ON NOVR` statements may be used to detect this
condition. This also permits addition and subtraction in larger
representation than 16 bits. _(See <<MULTIPLE PRECISION ARITHMETIC>> )_

Multiplication of two 16 bit numbers may result in a product
up to four bytes long. {cb} will detect this error _(See <<ON
ERROR GOTO>> )_ and preserve the high order 16 bits of the correct 2's
compliment result which can be accessed by the `OVEREM` function.

Division attempted with a divisor of zero will also produce
an error which is detected at run-time with the `ON ERROR GOTO`.
The Remainder of a division may be obtained by the `OVEREM`
function: `A=OVEREM`.


=== Multiple Precision Arithmetic
Sometimes it is necessary to deal with numbers larger than
the basic 2 byte {cb} representation. {cb} allows
addition and subtraction of numbers of multiples of 16 bits by
means of the `ON OVR GOTO` an `ON NOVR GOTO` statements. `OVR` means
"OVERFLOW" (carry or borrow as represented by the MPU C bit) and
`NOVR` means "NOT OVERFLOW".

The example below shows addition and subtraction of 32 bit
integers using the convention that two variables are used to store
each number: *A1* and *A2* are the first number with *A1* being the most
significant bytes ; and *B1* and *B2* used similarly. To add *A1-A2* to
*B1-B2* the following subroutine may be used:

[source, bbcbasic]
----
100 A2=A2+B2  : ON NOVR GOTO 200: REM ADD L.S. BYTES
150 A1=A1+1   : REM ADD 1 TO MS BYTES FOR CARRY
200 A1=A1+B1  : REM ADD MS BYTES
----

To subtract *B1-B2* from *A1-A2* a similar routine is used:

[source, bbcbasic]
----
100 A2=A2-B2 : ON OVR GOTO 200 : REM SUB. LS BYTES
150 A1=A1- B1 : RETURN : REM SUB MS BYTES & RETURN
200 GOSUB 150 : A1=A1-1 : RETURN : REM BORROW CASE
----

=== Extended & Decimal Addition & Subtraction

In many cases it is desirable to use decimal numbers or numbers larger than +/-32767. Although {cb} cannot handle numbers larger than this directly, simple addition and subtraction of fixed decimal or large numbers can be easily handled using multiple variables. By using multiple variables, each 3 or 4 digits of a large number can be assigned to a single variable to form a very large number of 6 or more digits.

In the following example we will use 2 variables to represent a decimal number with a fixed decimal point for a cents value. The total value for the sum cannot exceed 32767.99 in this form. This is not the only method to process decimal numbers as strings can also be used to allow a wider range of decimal values to be input and processed.

In this example ten numbers will be input from the keyboard and added together. The array "V" contains 10 elements each with two variables V(O) and V(l). In this example the numbers input from the keyboard are assumed to have a fixed decimal point for cents and cannot exceed 32767 since they are being input as numeric variables. If a value of 1000 is entered, it is assumed to be 10.00, 1222 would be 12 22 and 150 would be 1.50.

[NOTE]

The maximum input value is thus 327.67 for this example.

[source, bbcbasic ]
----
100 DIM V(1,10): T0=0 : T1=0 : REM DEFINE ARRAY, CLEAR TOTAL
110 FOR I= 1 TO 10 :REM SETUP INPUT LOOP
120 INPUT "ENTER NUMBER TO BE ADDED " ; A
130 REM
140 REM CONVERT NUMBER TO DOLLARS & CENTS
150 REM
160 V(0,I)=A/100: REMASSIGN DOLLAR VALUE
170 V(1,I)=OVEREM: REMASSIGN CENTS VALUE
180 NEXT I
190 REM
200 REM NOW ADD UP THE NUMBERS IN THE ARRAY
210 REM
220 FOR I = 1 TO 10
230 T1=V(1,I)+T1 : REM ADD THE CENTS TOGETHER
240 TO=V(0,I) +T0+T1/100 :REM ADD THE DOLLARS & CENTS OVER 100
250 T1=OVEREM: REM CENTS = REMAINDER OF DIVIDE
260 NEXT I
270 REM
280 REM NOW PRINT THE TOTAL FOR THE ARRAY
290 REM
300 PRINT "TOTAL= " ;
310 REM CONVERT DOLLARS TO STRING A$ WITH $ SIGN
320 A$="$"+STR$(TO)
330 REM CONVERT CENTS TO STRING B$ WITH DECIMAL POINT
340 REM ADD A LEADING ZERO IF ITS VALUE IS LESS THAN 10
350 B$=". "+RIGHT$("00"+STR$(T1),2):REM  ONLY 2 DECIMAL PLACES
360 PRINT A$;B$ : GOTO 100 :REM PRINT & GO DO IT AGAIN
----

For cases where multiply, divide or even floating point
arithmetic must be used, external subroutines may be used. In
such cases several compiler features and capabilities may be used
to simplify the interface.

1) Use the `EXEC` or `CALL` statement to call subroutines.

2) Set up conventions so values are passed to the external
subroutines in certain memory addresses that have been
assigned {cb} variable names so the {cb} program may
easily manipulate them.

3) Use {cb}'S string processing capabilities to full
advantage in handling I/O and storage of numeric values.
Floating point numbers can be passed as ASCII strings.

== BASIC Functions

=== Hardware Functions

==== BUTTON Statement

*Syntax:* `BUTTON`(_expr_)

The `BUTTON` function is used to tell if a selected Joystick button is pressed. If the selected Joystick button is pressed, the function will return a value of 1. If the button is not pressed a value of 0 is returned. The expression must evaluate toa number between 0 and 3 to be valid. The following values will select the different Joystick buttons:


[width="80%",align="center"]
[cols="20,40,40"]
[frame=none,grid=none]
|===
|0  | Right Button 1 | Old joystick (Single Button)
|1  | Right Button 2 | Newer Joystick (Dual Button)
|2  | Left Button 1  | Old joystick (Single Button)
|3  | Left Button 2  | Newer Joystick (Dual Button)
|===

Example:: `IF BUTTON(0) = 1 THEN 200`

==== JOYSTK Statement

*Syntax:* `JOYSTK`(_expr_)

The `JOYSTK` function is used to get the horizontal or vertical
position of the Left or Right Joystick. It returns a value
between 0 and 63 to represent the position. The expression must
evaluate to a number between O and 3 to be valid. The following
values will select t he different joystick and their horizontal or
vertical value:

[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|0  | Right joystick horizontal coordinate
|1  | Right joystick vertical coordinate
|2  | Left joystick horizontal coordinate
|3  |Left joystick vertical coordinate
|===

Example:: `H = JOYSTK(O)`


=== Special Functions

==== Run-Time SWITCH variables

*Syntax:* `SWITCHn` _= numeric expression_

Example:: `var = SWITCHn` +
    `SWITCH$ = string expression` +
    `var$ = SWITCH$`


The `SWITCH` variables are run time variables that occupy the first 16 bytes ($00-$0F) on the direct page of memory used by the {cb} program. There are eight numeric variable switches that can be uses or one 16 byte string variable, `SWITCH0`-`SWITCH7` and `SWITCH$`.

They both occupy the same memory space and can be used like any other variables in {cb}. They can be useful for temporary variable storage or for passing variables to & from machine language programs or subroutines and {cb} programs.

Since the `SWITCH` variables are not initialized by the {cb} program, they can be useful for passing information to a {cb} program before it is executed or from one {cb} program to another "CHAIN-ed" {cb} program that uses the same Direct Page of memory.

Example:: `SWITCH1=A` +
          `AB(I)=SWITCH3` +
          `SWITCH$=A$` +
          `A$="HELLO "+SWITCH$`

=== STRING Processing

{cb} features a complete set of string processing capabilities which allow {cb} programs to perform operations on character oriented data. Character type data is represented in {cb} in "string" form which is defined as variable length sequences of characters terminated with a null (00) character.

==== String Literals

A string literal or constant consists of a series of characters enclosed in quotation marks:

`"This is a string literal"`

Any character may be included in a string literal except for the ASCII characters for carriage return or null. A string literal may include up to 255 characters. If a quote is to be included as part of the string two are used so the literal: 

`"An embedded ""Quote"" = An embedded "Quote"` 

==== String Variables

[.load]
{cb} allows string variables which may be either single strings or arrays of strings. String variable names consist of one letter and a digit 0-9 or two letters A-Z followed by a dollar sign such as `A$`, `AX$` , `A1$` or `Z$`.

String variables may be used with or without explicit declarations. If a string variable is encountered for the first time in the source program as it is being compiled without having been previously declared in a `DIM` statement, the compiler will assign 32 bytes of storage for the string. The "maximum" number of characters that may be assigned to the variable. If the assignment statement produces a result which has more characters than assigned for the variable the first _N_ characters will be stored where _N_ is the length of the variable storage assigned.

A string variable or array may be declared to have a size of 1 to 255 characters in length if, the string is declared by a `DIM` statement before it is used _(see DIM statement description)_.

If the string name is declared as an array, the maximum subscript size is 32767. There are various allowed formats for using string arrays that require only one subscript (which may also be an expression). 

Some Examples ::  `A$(5)` + 
        `AX$(x+5)` +
        `Zl$(A+(N/2))` + 
        `BB$(X*Y)`

==== String Concatenation

The string concatenation operator `+` is used to join strings to form a new string or string expressions. 

Example:: `"NEW "+"STRING"` produces the new string value: `"NEW STRING"`

==== Null Strings

Strings which have no characters are represented as the literal `""` which represents an empty string. This is typically the initial value assigned to a string which is to be "built up".

The string assignment statement: `A$=""` is somewhat analogous to the arithmetic assignment `A=O` in the sense that both cause a variable to be assigned a defined value of "nothing". This is important because before a string variable is used in a program it has a value which is random and meaningless.

=== String Functions

{cb} includes many functions which manipulate strings or convert strings to or from other types. Some of the functions which include `$` in their name produce results which are of the string type and may be used in string expressions. In the description of string functions that follow, the notations : _N_ - refers to a numeric constant, variable or expression. _X$_ - refers to a string literal, variable or expression.

The following functions produce STRING results : 

==== CHR$(N) 
Returns a character which is the value of the number _N_ in ASCII.

==== LEFT$(X$,N)
Returns the _N_ leftmost characters of the string `X$`. 

Example:: `LEFT$("Example",3)` returns "Exa"

==== MID$(X$,N,M)
returns a string which is that part of the string `X$` beginning wit h its Nth character and extending for _M_ characters. 

Example:: `MID$("Example",3,4)` returns "ampl". 

==== MID$(X$,N,M)=Y
Replace a  portion of a string variable `X$` starting at position _N_ for a length of _M_, with the string `Y$`

==== RIGHT$(X$,N)
Returns the N rightmost characters of the string X$. 

Example:: `RIGHT$("Example",3)` returns "ple".


==== STR$(N)
Is a function used to convert a numeric value to a string of characters which are decimal digits.

Example:: `STR$(1234)` returns the "string" "1234". This is the opposite of the `VAL` function.

==== STRING$(N,M)
Is a function which creates a string of N characters in length specified by the ASCII code M.

Example:: `STRING$(10,49)` or `STRING(10, "1")` both produce the string "1111111111" , however the numeric form produces almost half as much code as the string from "1".


==== TRM$(X$)
Is a function which removes trailing blanks or spaces from a string and is typically used after a string is read from input. 

Example:: `TRM$("Example ")` returns "Example" + 
 Removes the space after "e"

==== HEX$(N)
Is a function which converts the value of a numeric expression into a string of characters that represent the hexadecimal equivalent of the expression. 

Example:: `HEX$(255)` returns `FF`

==== INKEY$
Is a function that returns a single character string equal to the character value of the key pressed on the keyboard. If no key is pressed on the keyboard, a null string "" is returned. 

[NOTE]
With regards to the preceding functions: If there are not enough characters in the argument to produce a full result, the characters returned will be those processed until the function "ran out" of input, or a null string, whichever is appropriate.

[WARNING]
The `STR$(N)` function will result in a run-time error detectable by the *ON ERROR GOTO* function if its argument is not legal or convertible to a string.

The following functions have string argument(s) and produce a result which is of numeric type.

==== ASC(X$)
Returns a number which is the ASCII value of the first character of the string. 

For example::  `ASC( "Example")` returns a value of *$45* or decimal *53* which is the ASCII code for the character *E*. This is the inverse function of `CHR$`.

==== LEN(X$)
Returns the length of a string. 

Example:: `LEN("Example")` returns a 7 +
 `LEN("")` returns a value of 0

==== INSTR(N,X$,Y$)
Is a substring search function which searches the string `X$` beginning at position `N`, for the substring `Y$`. If N is omitted the search begins with the first character in `X$`. If an identical substring is found the function will return a number which is the position of the first character of the substring in the target string. If the substring is not found the function returns a value of 0. 

Examples :: `INSTR("Example","pl")` returns a value of 5. + 
`INSTR( "Example", "NO")` returns a value of 0. If `Y$`="" the value of `N` is returned.

==== VAL(X$)
Converts a string of characters for decimal digits and optionally a leading minus sign to a numeric value. This has the inverse effect of `STR$`. If the string argument is not a legal conversion string (it has too many, non-decimal or not digit characters 0-9) a run-time error detectable by `ON ERROR GOTO` occurs. 

Example:: `VAL("123")` returns the numeric value of `123`. `VAL("THREE")` results in an error.

=== String Operations on the I/O Buffer
Commonly the BASIC language has limitations because of the input formatting when reading mixed data types. For example; BASIC input conventions cause commas that are part of the input data to break up what is a really long string, etc. {cb} has a special string variable, `BUF$` which is defined to be the contents of the run-time I/O buffer which may be used as any other string variable. `BUF$` is 255 bytes in length. 

[NOTE]
The I/O buffer is not used during Random Disk access `GET` & `PUT` functions.

The following I/O statement forms are legal for filling or dumping the I/O buffer when used with `BUF$`:

Example:: `INPUT BUF$` +
          `INPUT #N,BUF$` +
          `PRINT BUF$` +
          `WRITE #N,BUF$`

*Using `BUF$` as a variable* :: `BUF$ = MID$(BUF$+A$,N,M)`


==== SWAP String Statement

*Syntax* : `SWAP$`(_string var_,_string var_)

This command is used to exchange the contents of two string variables without the need for a temporary variable. It is equivalent to something like swapping the variables `A$` & `B$` which would require code similar to: `C$=A$` : `A$=B$` : `B$=A$`. `SWAP$` performs the same operation without having to use an intermediate variable, generates much less code and executes faster. This can be a very handy function and speedup factor when doing string sorts. String literals or functions can not be used, only valid string variables are allowed.

Example:: `SWAP$(A$,B$)` +
          `SWAP$(A$(I),A$(I+l)`

==== String Expressions

String Expressions String expressions may be created using string variable names, the concatentation operator and string functions. Expressions are evaluated from left to right and the only precedence of operations involved is the evaluation of function arguments is performed before concatenation. 

At run-time, string operations are performed on data moved to the "String Buffer", a compiler-allocated area normally 255 bytes long. Because this is always the last data storage area allocated by the compiler (st), any memory available beyond this may be used to allow automatic buff er expansion if operations on extremely complex string expressions are involved. 

Examples :: `"CAT"` +
`AZ$` +
`LEFT$(BC$,N)` +
`A$+RIGHT$(D1$,XX)+"TH"` +
`MID$(A$+B$,N,LEN(A$)-1)` +
`"AA"+LEFT$(RIGHT$(TRM$(A$)+B$,Z4),X+2)+C$`

==== String Comparisons

Strings may be compared in an `IF` expression the same as numeric expressions. Each character in the string is numerically evaluated by its ASCII character value for relational operations. Remember that puncuation and numeric characters have values that are less than normal text characters. Upper case text characters also have values less than Lower case text characters.

=== Compiler Directives

==== ORG, BASE and DPSET 
*Syntax*:  `ORG = address` +
    `BASE = address` +
    `DPSET = address(MSB only)`

These statements are used to control how {cb} assigns memory in and for the object program. The `ORG` statement is used to assign starting addresses for the object code, and the `BASE` statement is used to define the addresses used for variable storage. The `DPSET` statement is used to set the direct page reference value for variable storage. In most cases these statements need not be used at all in standard basic program as the program default values will provide for the optimum program configuration.

Both the `ORG` and `BASE` statements may be used as often as desired so memory assignments for variables and data storage may be segmented as desired. 

{cb} uses three internal *pointers* that control how run-time memory is allocated. The "object code pointer" always maintains the address where the next instruction generated by the compiler will be stored. The `ORG` statement assigns a value to this pointer. When {cb} is first started up, a default value of `$1000` is assigned to the pointer to allow space for the Direct Page (`$OF`). So unless an `ORG` statement is processed before the first executable BASIC statement, the programs default starting address is `$1000`. 

Example:: `0RG=$4000`

This will cause instructions generated for any following BASIC statements to begin at address `$4000`. The `ORG` statement may be used to create "modules" at different addresses within a single program. The `BASE` statement is also used to control memory assignment in a similar manner but it applies to allocation of RAM for variable storage. An internal "data address pointer" is maintained by {cb} to hold the next address available (at run-time) for variable or temporary storage, in addition to the BASE address pointer. The internal pointer is initialized by the compiler to allocate storage immediately following the compiled program, and the `BASE` address pointer is initialized to `0000`, which means that it is not being used currently.

{cb} assigns RAM corresponding to BASIC variables the first time they are encountered in the source program at compilation time. When a "new" variable name is encountered, {cb} assigns the variable run-time storage corresponding to the current value of the internal data address pointer which is then updated by increasing it by the size of the variable storage assigned, as long as the `BASE` address pointer is equal to `0000.` If the `BASE` address pointer is not zero, then its value will be used as the next variable storage location and it will be increased accordingly to point to the next available RAM location. 

An important function of the `BASE` statement is to allow specific memory assignments for specific or special variable names. Some of the reasons for this application are as follows:

1. To take advantage of the normally unused upper 32K of RAM for large arrays and variable storage. 
2. To assign specific variable names and types with memory addresses which have special functions or values. For example addresses of PIA's, X-Pad, 80 coulmn cards, RS-232 cards or other interface devices which have control or status registers, may be given BASIC variable names. A common type of "trick" is to declare the memory used by video displays or graphics memory to be declared as a BASIC array. 
3. The BASE statement can assign locations to specific variables without disrupting the normal internal data address pointer, and then allow normal allocation to resume by assigning a value of zero to the `BASE` pointer (`BASE=OOOO`). The `BASE` statement can also be used for allocating all variable storage by simply setting the location at the beginning of the program and us i ng only the BASE pointer for variable allocation.

When using the `ORG` and `BASE` statements the programmer must take care to e nsure that there are no conflicts or overlaps between program and data storage, by using assignments which are not overlapped. If the BASE statement is not used, the Compiler will automatically select the correct locations for variable storage. Sometimes it is useful to declare a variable without generating code at the time it is declared. 

If the variable is an array, the `DIM` statement may be used. If it is a simple type, the `DIM` statement declaration with a size of one may be used for a declaration. For example, to assign the address `$FFOO` to the variable `KB` the following sequence may be used.

Examples:: `BASE=$FFOO` +
`DIM KB(l)` +
`BASE=OOOO`

==== PCLEAR

*Syntax*: `PCLEAR` _[0-8]_ 

The PCLEAR statement is normally associated with Graphics. You use it to clear (reserve) a number of graphics pages. In {cb} the `PCLEAR` statement is similar to an `ORG` statement in that it changes the address where the compiled program will be in memory. It will also change the Direct Page reference according to the number of pages to be reserved. The `PCLEAR` statement must be used in a {cb} program before any statements that generate machine code, otherwise an error will occur. The number of graphics pages to clear can be in the range from 0 to 8.

==== DIM Statement

*Syntax*: `DIM` _variable_ _`(`dimension`)`_ 

This statement is used to declare arrays and optionally other simple variables. Arrays must be declared in a `DIM` statement and may be used to declare more than one array. Arrays may not be redefined in following `DIM` statements. Array subscripts have a legal range of 0 to 32767.

Examples:: `DIM R(65)`
  `DIM W(8), X(8) ` +
  `DIM AR$(8,25)`

==== Numeric Arrays

Numeric arrays may be declared to have one or two dimensions. Two dimensional arrays are stored in row-major order. Each element of a numeric array requires two bytes of storage. A two dimensional array may be accessed as a one dimensional array, this is alowed so large one dimension may be used. 

Example:: `DIM B(2000), CX(10,20), D1($10,$20)`

==== String Arrays

String arrays may only be one dimensional, however, the DIM statement is also used to specify the string size (1 to 255 characters) so the declaration for a one dimensional string will have two subscripts: the number of strings and the length of each string. A single string may be declared in the DIM statement with a length specification only. 

Examples:: `DIM A$(80)` one string of 80 characters +
           `DIM B$(500,72)` 500 strings of 72 characters 


In the example above, `A$` is used in the program *without* any subscripts because it is not an array. `B$` would be used in the program with "one" subscript because it is a one-dimensional array. 

For example :: `A$=B$(N)`

==== Declaring Simple Variables

Because {cb} allocates memory for variables as they are encountered for the first time, it is often useful to declare a single name so it may be assigned storage at a particular point, but without generating code. This is often the case when it is desired to assign a variable a certain memory address. {cb} processes a variable declared as an array but used without subscripts in the program as the first element of the array by internally assuming a subscript of (0) for a one dimensional array or (0,0) for a two dimensional array. Because of this a declaration of a variable in a `DIM` statement with a subscript of 0 is legal, but the variable may be used throughout the program without a subscript.

Example:: Suppose a program is to be used to read from and write to a Serial RS 232 interface card at address `$FF68 - $FF6B` and an X-PAD at address `65376 - 65378 ($FF60-$FF62)`, and they are to be assigned variable names. A `DIM` statement at the beginning of the program may be used to assign variable names to these devices: 

[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|`BASE = $FF68`     | Set compiler address pointer
|`DIM DS(0),CT(0)`  | Declare RS232 data/status/command/ctrl regs.
|`BASE = $FF60`     | Set address pointer to X-Pad
|`DIM XY(0),XS(0)`  | Declare x,y reg. and status reg.
|`BASE = 0000`      | Restore internal data pointer to normal
|===

The program may now refer to either the RS-232 port or the X-Pad registers thru the variable names RS, XY, or XS. 
[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|`CT=N`     | To write the RS232 command/ctrl registers
|`N=DS`     | To read the RS232 data & status registers
|`N=XY`     | Read X & Y location regs on the X-PAD
|===

==== REMARK Statement

*Syntax*: `REM`  or `'` _followed by comment text_

The `REM` statement is used to insert comments in the BASIC source program. The first three letters must be `REM` or the first character is a single quote {rem}. All characters following the `REM` or single quote charadter are considered to be comments until an end of line or until a colon `:` character is reached.  

[TIP]
The `REM` statement does not affect the object program size or speed as it does not generate any code. 

Examples:: `REM This is a comment`  +
           `' IS ALSO A COMMENT`


==== TRACE 

*Syntax* : `TRACE` _ON/OFF_

The `TRACE` statement is useful for debugging programs that cause an `FC` "Function Call" error at run-time. When the compiler is instructed to turn the `TRACE` mode on, it will automatically generate the code required save the line number of each statement before it is executed. If an error occurs during the execution of the statement and `ON ERROR` is disabled, the program will pass the line number of the statement in error to {ecb} before the halt is executed. When `TRACE` mode is enabled it will increase the size of the program by 5 bytes for each line of code. The `TRACE` mode can be turned `ON` or `OFF` at any time within the program.

`TRACE` must be enabled for the `ERL` function to operate.

Example :: `TRACE ON`

==== HIRES 

The `HIRES` statement is used to inform the compiler that you would like the Hi-Resolution Text Display functions to be included in your program. The `HIRES` statement must be used in the beginning of the BASIC program before any program lines that will cause code to be generated. If the `HIRES` option is included in your program, it will increase the size of it by almost 2K and it will use the Screen memory normally used for the `WIDTH 80` display.

It will afford you many enhanced screen display formats as well as the ability to use `PRINT @` on the 32/40/64/80 column displays.

[NOTE]
See Appendix D for HI-RES Screen Commands & Functions. 

Example :: `HIRES`


==== MODULE

The `MODULE` statement is used when you want the compiler to generate the code required to preserve the MPU registers and the Stack of a calling program before initalizing the Stack & Direct Page registers for the compiled programs use. It will also instruct the compiler to ignore the `HIRES` statement if used and generate the code required to restore the MPU registers and Stack when an `END` or `STOP` statement is executed. This can be useful for creating separate modules that can be called from a compiled program. Variable storage will still be allocated normally so variables tha t are to be passed from the calling compiled program must be coordinated by the `BASE` and `DIM` or `SWITCH` statements if required.

Example :: `MODULE`

=== I/O Structure Changes

{cb} extensivly changes the I/O structure of the CoCo-3 to add support for the RS-232 port and to improve interrupt handling in 64K modes of operation. Because of these changes, a compiled porgram automatically re-vectors several {ecb} hooks. The program automatically inserts its own vectors in these locations and preserves the old vector information. The program will automatically restore these vectors when the compiled porgram is exited via an `END`, `STOP` or `CHAIN` command. This is important to remember when using more than one compiled program in memory at the same time or using the `LOADM` & `EXEC` commands to execute another {cb} program, since the second or third program will also re-vector these hooks. 

If the current program was not un-linked before exiting, un-predictable results will occur. The same problem will exist if you try to exit a compiled program into another machine language program or into basic using a `CALL` or `EXEC` statement. We have Therefore provided two additional commands to allow you to manually `LINK` or `UNLINK` the {cb} program.

==== UNLINK 

This command will "unlink" or restore the original vector information to be the same as it was found before the program was executed (normal {ecb}  vectors). It would normally be used before you use the `CALL` or `EXEC` statements to exit from a {cb} program. When a program is unlinked, `HI-RES`, `RS-232`, `ON IRQ` and `ON ERROR` functions will no longer be functional. You can use the `UNLINK` command at any time within the program, however it is not advisable unless you plan to exit the program.

_Example:_ 

[source, bbcbasic]
----
1020 UNLINK:EXEC $A027: REM unlink & do basic reset
----

==== CBLINK 
 
This command will allow you to relink the {cb} program manually if you have previously unlinked it and executed another program and returned. If the program has not previously been unlinked it will not try to relink itself, so no conflict will occur. 
 
_Example:_ 

[source, bbcbasic]
----
1020 UNLINK:EXEC $4800: REM go do sort & list` 
1030 CBLINK:REM restore program links
----

=== Assignment Statements

==== LET (Numeric)

*Syntax*: `LET` _(variable=numericexpression)_

Used for arithmetic assignments.  The expression is evaulated and the result is stored in the variable. 

[TIP]
Use of the keyword `LET` is optional.

==== LET (String)

*Syntax*: `LET` _(variable=stringexpression)_

The string expression is evaluated and the result assigned to the string variable specified. If the result of the evaluation produces a result with a longer length than the size of the result variable, the first N characters only are stored where N is the length of the resulting variable.

[TIP]
Use of the keyword `LET` is optional.

==== POKE & DPOKE

*Syntax*: `POKE` (address, value) + 
`DPOKE` (address, value) 

The `POKE` and `DPOKE` statements are used to place a single byte, ( `POKE` ) or double byte, ( `DPOKE` ),  variable or value at a specified location in memory. The address and value can be any valid numeric expression or variable. If numbers are used for both the address and value the shortest and fastest possible code will be generated. When using `POKE` only the least significant byte of the result is stored. When using `DPOKE` the full 16 bit value is stored at the _address_ and _address+1_.

==== DATA

*Syntax*: `DATA` _(value)[,value,... ,value]_

The `DATA` statement is used to store information in the program that is to be read in by the program. The data can be either in a numeric or string form, and can be placed anywhere in the program. The compiler will automatically assign it to a data storage area that is invisible to the user. If a `DATA` statement is used on a multiple statement line, it must be the last statement on the line. All information following the `DATA` statement up to the end of the line is considered to be valid information.

Example:: `DATA 7,Sun,Mon,Tue,Wed,Thur,Fri,Sat` +
          `DATA 10,12,14,18,57,99,109,33,Horses,Cows`

[NOTE]
The examples demonstrate that mixed numeric and text can be stored on the same line. It is up to the programmer to know what type of information is stored in the data statements before reading it into the program with the `READ` statement.


==== READ

*Syntax*: `READ` _(var){nbsp}[,var,... ,var]_

The `READ` statement is used to read data from a `DATA` statement as explained in the preceding paragraphs. The `READ` statement can be used with more than one variable if desired. When a `READ` statement is followed by more than one variable, each variable is assigned the next available piece of data. If a `READ` statement tries to read past the end of all data statements it will automatically be assigned a value of zero for numeric variables and a null string "" for string variables. If `ON ERROR` handling is enabled it will generate an out of data error.

_Example 1:_

[source, bbcbasic]
----
10 DATA 7,Sun,Mon,Tue,Wed,Thur,Fri,Sat
20 READ N : REM read # of items of data
30 FOR I = 1 TO N
40 READ A$(I) : NEXT 
----

_Example 2:_

[source, bbcbasic]
----
10 DATA Sun,Mon,Tue,Wed,Thur,Fri,Sat
20 READ A$,B$,C$,D$,E$,F$,G$,H$
----

In the first example the value of "7" was read from the `DATA` statement first and then that value was used to count how many items of data were to be `READ` from the `DATA` statement. In the second example all the data was read with a single `READ` statement, only in this case there were 8 variables and only 7 items of data so the variable `H$` was assigned a null string value "".

==== RESTORE
*Syntax*: `RESTORE` 

The RESTORE statement is provided to allow re-read capability for the `DATA` statements. When a program is first run, the first `READ` statement causes the first element of data to be read, each succeeding variable of that `READ` statement and following `READ` statements will continue to read the next element of data sequentially. When a `RESTORE` statement is executed, it causes the "next available data pointer" to be reset to the first `DATA` statement of the program. The next `READ` statement executed after a `RESTORE` will begin reading data from the "first" `DATA` statement in the program.

_Example_: 

[source, bbcbasic]
----
05 DIM A(l0), B(l0)
10 DATA 10,9,8,7,6,5,4,3,2,1
20 FOR I=l TO 10
30 READ A(I) : NEXT
40 RESTORE
50 FOR X=l TO 10
60 READ B(X) : NEXT
----

The example shows the array `A(l0)` being first, then the `RESTORE` statement resets the beginning of data again. The array B(l0) is same values from the `DATA` statement.

==== EXEC 

*Syntax*: `EXEC` _address_ 

The `EXEC` statement is used to directly call a machine language subroutine at the address specified. If the address is omitted it will use the previous `EXEC` address or the one from the last `CLOADM` or `LOADM`. Before jumping to the address, the current Direct Page register contents will be saved on the stack and the Direct Page register will be set to zero for {ecb} ROM call compatibility. Upon returning from the EXECuted program or subroutine, the DP register will be restored from the stack automatically. If the stack is altered by the EXECuted routine or it does not return with the stack intact, unpredictable results will occur. If you wish to have information from the Executed routine returned to the {cb} program, use the `BASE` & `DIM` or `SWITCH` variable statements to coordinate returned values.

Example:: `EXEC $A282`  *  Execute subroutine at address $A282 +
`LOADM"TEST" :EXEC`  *   Execute subroutine at address 1024

==== CALL

*Syntax*: `CALL` _address_

The `CALL` statement is similar to the `EXEC` statement in operation, except that it does not save the DP register or preset it to zero. It requires that the address be specified. It can be useful when you do not want the DP register to be set to zero or if the DP register is set using the `GEN` statement prior to the `CALL` statement. The `CALL` statement translates directly into the machine code for "Jump to Subroutine" (*JSR*). 

Example:: `CALL $1000` +
`CALL $A282`

=== Program Control Statements

==== FOR/NEXT

*Syntax*: `FOR` _var = expr_ {nbsp} `TO`  _expr_ {nbsp} `STEP`  _expr_ +
          `NEXT` _(var),...,(var)_ 


The `FOR/NEXT` statement uses a variable "var" as a counter while performing the loop ended by the `NEXT` statement. If no step value is specified, the increment value will be 1. The `FOR/NEXT` implementation in {cb} differs slightly from {ecb} due to a looping method that results in extremely fast execution and minimum length. 

The following are the characteristics of the `FOR/NEXT` operation:

* _var_ must be a non-subscripted numeric variable.

* The loop will be executed at least once reguardless of the terminating value.

* After termination of the loop, the counter value will be GREATER or LESS than the terminating value depending on the direction of the loop because the test and increment is at the bottom (`NEXT`) part of the loop.

* `FOR/NEXT` loops may be exited and entered at will.

* At compile time, up to 16 loops may be active and all must be properly nested.

* The initial, step, and terminating values may be positive or negative. The loop will terminate when the counter variable is greater than the terminating value in a forward loop (Ex. 1 to 10), or less than the terminating value in a reverse loop (Ex. 10 to 1). 

* There can be only one `NEXT` statement for any given `FOR` loop. Therefore you cannot use the structure: `IF A=1 THEN C=C+1: NEXT Y ELSE NEXT Y`. This will cause compiler errors and may cause the compiler to loop.

Examples:: `FOR N = J+1 TO Z/4 STEP X*2` +
`FOR A = - 100 TO - 10 STEP -2` +
`FOR I = 9 TO 3` (Reverse Loop) +
`FOR I = 3 TO 9` (Forward Loop)` +
`NEXT X,Y,Z` (More Than One Loop Var) +
`NEXT` (End Most Recent Loop Activated)

==== GOSUB/RETURN 

*Syntax*: `GOSUB` _line#_ +
          `RETURN`

The `GOSUB` statement calls a subroutine starting at the line number specified. If no such line exists, an error message will be generated on the second pass. The machine stack is used for return address linkage the same as a normal assembly language program. The `RETURN` statement terminates the subroutine and returns to the statement following the calling GOSUB. Subroutines may have multiple entry and return points. The `GOSUB` and `RETURN` statements compile directly to `JSR` and `RTS` machine language instructions, respectively.

==== IF/THEN

*Syntax*: `IF` <expr> <rel.> <expr> `AND/OR` <expr> <rel.> <expr> +
`THEN` <statement(s)> `ELSE` <statement(s)> +
`GOTO` <line#> `ELSE` <statement(s)> +
`GOSUB` <line #> `ELSE` <statement(s)> 

The `IF/THEN`, `IF/GOSUB` or `IF/THEN/ELSE` statements are used to conditionally branch or execute statements, or conditionally call a subroutine based on a comparison of two expressions. Legal relations are:

[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|`<`  |less than
|`>`  |greater than
|`=`  |equal to
|`<>` |not equal to
|`<=` `=<`  |less than or equal to
|`>=` `=>`  |greater than or equal to
|===

If the statement is an `IF/GOSUB` the subroutine specified will be called if the relation is true and will return to the next line # following. If an ELSE is used, statements or the line# following it will be executed if the relationship is False. The logical operators `AND/OR` may be used to test the results of several conditions in one statement.

Examples:: `IF N = 100 THEN 1210` +
`IF A=l AND C=2 GOSUB 550` +
`IF XZ=200 OR XY=l92 THEN 240 ELSE 1100` +
`IF XZ=200 THEN XY=240 ELSE GOTO 1100` +
`IF A$=B$ THEN C$="YES" : D$="NO" ELSE D$=YES"` +
`IF A$>B$ THEN 260 ELSE C$=A$`

==== ON ERROR GOTO

*Syntax*: `ON ERROR GOTO` +
`ON ERROR GOTO` _line#_ +
`ON ERR GOTO` _line#_

The `ON ERROR/ERR` statement provides a run-time error "trap"the capability to transfer program control when an error occurs. 

When an `ON ERROR GOTO` statement is executed the compiler saves the address of the line number specified in a temporary location. If any detectable error occurs during execution of following statements, the program will transfer control to the line number given in the ON ERROR GOTO statement last executed. This would normally be the line number where an error recovery routine begins. 

If the `ON ERROR GOTO` statement is used *WITHOUT* a line number specified, it has the effect of "turning off" the error trap errors in following statements will be ignored. 

After an error has been detected, the `ERR` or `ERNO` function may be used to access a value which is an error code identifying the type of error which most recently occured. The exact error codes are listed in the appendix. The `ERL` or `ERLIN` function may also be used to determine which line number the error occured in, providing that `TRACE` was *ON*.

The `ON ERROR` function if enabled will automat ically restore the *Direct Page* register and initalize the *Stack Pointer* to the top of the *Direct Page* (same as default *Stack Pointer* on startup). The types of errors that can be detected by `ON ERROR GOTO` and the types of statements they occur in are listed below:

[width="80%",align="center"]
[cols="50,50"]
[frame=none,grid=none]
|===
|Divide by zero                   | Arithmetic expressions
|ASCII to Binary conversion error | `INPUT`, `READ`, `VAL(X$)`
|Multiply overflow                | Arithmetic expressions
|Disk, Tape errors                | Disk, Tape I/O
|Syntax Errors                    | Hi-Res Graphics  `DRAW`, `PLAY`
|===

_Examples of usage:_

[source, bbcbasic]
----
100 ON ERROR GOTO 500
120 INPUT A(N)
130 N=N+l : IF N=SO THEN 600 :GOTO 120
600 PRINT "ILLEGAL INPUT ERROR - RETYPE": GOTO 120
----

==== ON BRK GOTO

*Syntax*: `ON BRK GOTO` _line#_

The `ON BRK` statement allows you to transfer control to a specified line number when the kbd:[BREAK] key is pressed. If the statement is used without a line number it has the effect of turning off Break key detection. If `ON BRK` is disabled (default) the kbd:[BREAK] key or kbd:[SHIFT,@] can be used to pause the display. {cb} only checks for an `ON BRK` condition when data is being output to the screen.

Example :: `ON BRK GOTO 1000`


==== ON-GOTO/ON-GOSUB

*Syntax*: `ON` _expr_ {nbsp}`GOTO` _<line#>_,... ,_<line#>_
`ON` _expr_ {nbsp}`GOSUB` _<line#>_,... ,_<line#>_

The expression is evaluated and one line number in the list corresponding to the value is selected for a branch or subroutine call. 

For Example:: if _<expr>_ evaluates to 5, the 5th line number is used. If _<expr>_ evaluates to zero or a number greater than the number of lines specified, the statement will be ignored and the next statement on the line or next line will be executed.

Examples :: `ON A*(B+C) GOTO 200,350,400,110,250` +
`ON N GOSUB 500,510,520,530,100`

==== STOP & END

*Syntax*: `STOP` or `END`

The `STOP` and `END` statements are used to terminate execution of a program by causing a *Cold Start* return to the {ecb} operating system. If the`MODULE` statement was used in the program these statements will generate the code required to restore all MPU registers and the *Stack Pointer* to the program entry conditions.

==== RUN

*Syntax: `RUN`

The `RUN` statement is used to re-execute the compiled program, just as if it were first executed. It will not close any open disk or tape f iles, like {ecb}. It simply performs a `GOTO` to the first execution address of the program.


=== System Control Statements

==== GEN

*Syntax*: `GEN` _number_, _number_,.... , _number_

The `GEN` statement allows data or machine language instructions to be directly inserted in the program. The list of values supplied are inserted directly into the object program. If a value given in the list is less than 255, only one byte will be generated for that value reguardless of leading zeros. This function can be very useful for directly inserting machine language subroutines in a BASIC program, as the line # for the beginning of the routine can easily be called via the Basic `GOSUB` statement and control returned to the calling `GOSUB` by ending the routine with an `RTS ($39)` instruction.

==== CLEAR 

The CLEAR statement has no function in {cb}, it is recognized for conversion of {ecb} programs. It is handled the same as a `REM` Statement.

==== ON RESET GOTO

*Syntax*: `ON RESET GOTO` _line#_

This statement allows a {cb} program to be re-initialized or continue execution at a specified line# in the program. Normally if the `RESET` button on the back of the computer is depressed during program execution, the machine is *Cold Started* and control is returned to {ecb}. The `ON RESET` statement is typically one of the first statements in a {cb} program if used, but may be used to re-define the *RESET* control vector at any time within the program. If an `ON RESET` statement is executed in the program, the only way to terminate program execution is thru a `STOP` or `END` statement. The compiler will automatically generate the pr oper code to re-initialize the *Direct Page* and *Stack* registers and 64K RAM if used. 

Example:: `ON RESET GOTO 5000`


==== STACK 

*Syntax*: `STACK` _= address_ 

This statement is used to initialize or change the MPU stack pointer register. Normally, the `STACK` statement is not required in a program as the compiler automatically uses the page of memory immediately prior to the beginning of the program. This is normally adequate for almost all programs, including extensive subroutine nesting and interrupt processing (200 bytes of Stack space). Otherwise, a specific memory area should be dedicated for the stack and the `STACK` instruction used to set the *TOP* of the stack (highest address). 

Example:: `STACK = $7FFF` 

[NOTE]
The stack builds downward


==== PAUSE

*Syntax*: `PAUSE ON` or `OFF` 

The `PAUSE` command allows you to select whether or not to allow output to the display to be paused by using the Shift @ key or Break key ({cb} only). Normally `PAUSE` is enabled by default when a {cb} program starts execution so it will work the same as a normal Basic program for stopping a display or detecting an ON BRK condition. However with the addition of `ON BRK GOTO` and `ON KBDIRQ` commands in {cb} the keyboard scan required to detect a pause key being pressed will make the ON KBDIRQ (explained later in the Interrupt commands) not to function properly. If you want to use the ON BRK command, the PAUSE function must be on since {cb} only checks for the Break key when data is being output to the Screen. 

Example: `PAUSE OFF` 

==== SIGN 

*Syntax*: `SIGN ON` or `OFF` 

The `SIGN` command allows you to select whether or not to add a leading space to positive numeric values output to a device. Normally {cb} supresses this leading space so that multiple numeric variables can be output together to represent larger numbers. Since {ecb} normally outputs this leading space, many programs expect it to be there when doing number to string conversions, etc. To make {cb} output the extra space, use the `SIGN ON` command. 

Example :: `SIGN ON`  _enable leading sign space_

=== Interrupt Processing Statements

Interrupt processing is not easily understood unless you are familar with the hardware of the machine and machine language programming. They can easily hang up a program or cause the system to crash unless used carefully. we have tried to make them easy for you to use by doing most of the tedious processing required for interrupt handling, but if not properly understood you can still have a lot of difficulty using them, so please beware. 

Also note that we recommend that only simple commands be used within an Interrupt processing subroutine, do not a t tempt to use any I/O commands or string manulipation commands since you can not determine what other functions may have been in progress when the Interrupt condition was detected and you may make the results of the function that was in progress totall y invalid or even hang the system.

==== ON INTERRUPT

*Syntax*: `ON KBDIRQ GOTO` _line#_  (Keyboard interrupt) +
`ON TMRIRQ GOTO` _line#_ (12 bit Timer interrupt) +
`ON SERIRQ GOTO` _line#_ (Serial data interrupt) +
`ON IRQ GOTO` _line#_ (60 cycle/other interrupt)

The `ON` _Interrupt_ commands allow you to do real time processing based on interrupt conditions. The *Keyboard*, *Timer* and *Serial* data interrupts are not normally enabled (or even available in Basic) and must be enabled via the `IRQ` statements after each time the interrupt occurs. If enabled, and one of these interrupts occur, the detected interrupt type will be disabled from re-occuring until an `IRQ=` statement is used to re-enable them. The reason for this automatic disable feature is that an interrupt may be processed continuiously in error. For instance if a *Keyboard* interrupt is detected and processed, the *Return from Interrupt* is executed and the Key is still pressed on the keyboard (Guaranteed). Which means that the Keyboard interrupt would be processed possibly thousands of times for a single key stroke.

A *Keyboard* interrupt can be generated by any key on the keyboard if the data line from the keyboard *PIA ($FF02)* output is at a zero level for that key column. For example,  to enable all keys for interrupt detection you would poke a "00" value at *$FF02*, or to enable the key column with kbd:[ENTER] kbd:[@]  kbd:[H] kbd:[P] kbd:[X] kbd:[O] kbd:[8] keys you would poke a "01" at *$FF02*. Also, at any time an `INKEY`, `INPUT` or other command that causes a keyboard scan (`PRINT` with `PAUSE` enabled) will change the value of *$FF02*. A good way to process a Keyboard interrupt is to simply set a flag variable and let the *main* program do the acutal *Key* scan with an `INKEY` and then re-enable the `KBDIRQ` when a key is no longer pressed. The `KBDIRQ` function should be disabled when using normal `INKEY`, `INPUT` and `GETCHAR` commands from the keyboard by using the `IRQ=` statement before attempting keyboard input.

A *Serial* data interrupt is generated when the RS-232 input data line on the computer goes from a zero state to a one state (serial data bit= l or printer status goes to not ready). It can not be used to detect a start bit for serial data since it is a one to zero transition which makes the Serial data interrupt of little value for Serial communications.

[NOTE]
It may become more useful in an future revision of the Coco3 if it becomes programmable by changing the inverter gate used to an Exclusive or gate with one input tied to one of the pia output lines (hint to R.S.). Until then it works basically the same as the `KBDIRQ` in that once detected it is disabled until re-enabled by use of the `IRQ=` statement.

A *Timer* interrupt is generated by the 12 bit programmable timer built into the GIMI chip (in case you didn't know). The *Timer* register at address *$FF94* & *$FF95* is loaded with a value least significant byte first *($FF95)*, with the count automatically beginning when the most significant byte *($FF94)* is loaded. As the count falls thru zero, an interrupt is generated (if enabled), and the count is automatically reloaded. As with the Keyboard & Serial interrupts, the *Timer* interrupt is disabled until re-enabled by the `IRQ=` statement. You can select the input clock to be either 63 micro seconds or 70 nano seconds by the *TINS* input *(bit 5 of $FF91)*. Default is the 70 nsec clock and we do not recommend that you fool with it since that register also controls the Memory Managment Unit Task Register Select, which if changed at the wrong time can crash the system instantly and it is not a readable register (so you never can tell whether the *TR* bit or *TINS* bit is *On* or *Off*. 

The normal `IRQ` interrupt is generated every 1/60th of a second by the vertical retrace interrupt in the computer (the same as the Coco 1 & 2), and is used for the *TIMER* value increment as well as `SOUND` and `PLAY` commands for timing. The `ON IRQ` statement will be executed if any `IRQ` interrupt is generated including *KBD*, *Serial* or *Timer* if a handler is not set up for that particular interrupt by an `ON TMRIRQ`/`KBDIRQ`/`SERIRQ` statement. Essentially it is a catch all interrupt handler. The 1/60th second interrupt is never disabled automatically like the other interrupts, so it will occur continuously unless disabled by some other means. Since this is a normal interrupt function, {cb} will automatically handle the interrupt even if you do not have and `ON IRQ` handler setup, so don't think you have to have one in a {cb} program, as you actually don't.

A few points to remember are that *ALL* interrupt handling subroutines must end with a `RETI` statement or you will have a crashed system. If you wish to disable one of the interrupt handlers that have already been in use, then use the same statement without a _line#_. 

Example::  `ON KBDIRQ GOTO` instead of `ON KBDIRQ GOTO 1000`

==== IRQ

*Syntax*:  `IRQ =` _value_ +
`IRQ ON` +
`IRQ OFF`

The `IRQ` statements are used to enable or disable IRQ & FIRQ interrupt detection either entirely or partially. The `IRQ ON` statement is used to disable the detection of all `IRQ` interrupts by setting the 6809 MPU mask bits for interrupt detection. The `IRQ OFF` statement clears the 6809 MPU mask bits and allows the detection of all *FIRQ* & *IRQ* types. It is recommended that you use a `IRQ ON` command before setting up `ON` _Interrupt_ handlers and then using the `IRQ OFF` statement to enable them when finished.

The `IRQ=` statement is used to selectively enable or disable *GIME* interrupt conditions. There are six different interrupt conditions that can be enabled by this stat ement which gives 64 possible interrupt combinations. They are selected by adding together the bit values of the interrupt enable bits. To activate an interrupt condition, you set the bit on and off to de-activate it.


[width="80%",align="center"]
[cols="10,40,10,40"]
[frame=none,grid=none]
|===
|1  | Cartridge IRQ         | 2 |  Keyboard IRQ
|4  | Serial data IRQ       |8  |  Vertical Border IRQ
|16 | Horizontal Border IRQ |32 |  Interval Timer IRQ
|===

[WARNING]
These values are *OR'd* together and stored in location *$FF92 IRQ* or *$FF92 FIRQ*

If you wanted to enable the *Keyboard* and *Timer* interrupts you would use a value of 34 (2 for the `KBD` + 32 for the `TIMER`). If you are working with more than one interrupt, you should keep a variable with the value of all interrupt conditions and use bit operators like *AND (&)* and *OR (!)* to set and reset the bits to be enabled.

_Example:_

[source, bbcbasic]
----
10 IRQ ON : ON TMRIRQ GOTO 100 : IRQ = 32
20 POKE $FF95,0 : POKE $FF94,4 : IRQ OFF
30 TI = 0 : REM COUNT= O, IRQ EVERY 1024 CLOCKS
40 PRINT@0,"TIMER COUNT = "; TI
5O GOTO 40
100 TI = TI + 1 :REM ADD 1 FOR EACH TIMER IRQ
120 RETI
----

[WARNING]
These are *GIME* interrupts and require that location *$FF90* be setup to allow interrupts to reach the CPU. Examples: `$FC` for COCO2 +
`$7C` for COCO 3 Screens.

==== Other ON INTERRUPT Statements 

*Syntax*: `ON FIRQ GOTO` _line#_ Must Save Registers Manually* `FIRQ` +
`ON NM! GOTO` _line#_  `GEN $3406` to *PSHSD*  at start of `IRQ` code + 
`ON SW! GOTO` _line#_  `GEN $3506` to *PULSD* before `RETI`

These statements are used for generating programs where interrupts are processed by specific service routines rather than by the normal {ecb} service routines. When encountered in a program these statements cause the absolute address of the Basic program line specified to be stored at the interrupt vector addresses in the operating system memory. The line number specified should be the beginning of the interrupt service routine which would typically service the device causing the interrupt. This routine is similar to a BASIC subroutine except it is terminated by an `RETI` (return from interrupt) statement instead of a `RETURN` statement. These are not normally used unless you have a good understanding of how the MCC6809 interrupt structure works.

==== RETI 

*INTERRUPT RETURN* 

*Syntax*: `RETI`

The `RETI` statement is used to terminate an interrupt-caused routine by loading the MPU register contents prior to the
interrupt from the machine stack, and resuming program execution from the point where the interrupt was acknowledged. This
statement corresponds directly to the machine language *RTI* instruction.

=== Interrupt Simulation Statements 

==== IRQ, NMI, FIRQ, SWI

*Syntax* : `IRQ` : `NM!` : `FIRQ` : `SWI` 

These commands allow you to simulate an interrupt via software in a {cb} program. They can be useful for testing interrupt handling routines without having to use live interrupts and for special function handling in a program. These commands cause the current processor registers to be saved on the stack & interrupt masks to be set the same as their hardware counterparts. 

On interrupt handlers should use the `RETI` command to exit the routine the same as if it were handling a hardware interrupt. All interrupt simulation commands generate 11 bytes of code to simulate the interrupt except the `SWI` command which generates only 1 byte for the `SWI` code. Note that `SWI2` and `SWI3` interrupt vectors are reserved for use by the compiled programs and are not available for use by the programmer.

<<< 
=== Extended Memory Management

==== LPOKE and DLPOKE 

*Syntax*: `LPOKE` _page#_,_offset_,_value_+
`DLPOKE` _page#_,_offset_,_value_

NOTE: `LPOKE` behaves differently than {ecb} +
 `DLPOKE` is not available in {ecb}
 
 The `DPOKE` and `LPOKE` commands are used to place a single byte `LPOKE` or double byte `DLPOKE` variable or value in a specified extended memory location (00000- 7FFFF). The _page#_ value is used to select which 64K bank (0-7) is to be used. The _offset_ selects which address in the selected page to use (0 - FFFF) and the value is the data to be stored at that location. The _page_ _offset_ and _value_ can be either numeric or variables used to specify the information. When using the `LPOKE` statement only the least significant byte of the result is stored while `DLPOKE` will store the full 16 bit value.

Examples: `DLPOKE 6,0,255` +
`LPOKE 6,0,&HFFFF`
`LPOKE P,OF,VA`

==== LPEEK and DLPEEK 

*Syntax*: `A=LPEEK(`_page#,offset_`)` +
`A=DLPEEK(` _page#,offset_ `)`


NOTE: `LPEEK` behaves differently than {ecb} +
 `DLPEEK` is not available in {ecb}

The `LPEEK` and `DLPEEK` commands are used to examine or get the information stored in a specified Extended memory location. The _page#_ specifies which 64K bank of memory (0-7) and the offset selects which address within that 64K block is to be accessed (0-FFFF), the same as the `LPOKE` command. If the `LPEEK` command is used a single byte value will be read and stored in the least significant byte (0-255 only) and the `DLPEEK` command will return a full 16 bit value from the two consecutive bytes. 

Example :: `A= LPEEK(6,10)` +
`A = DLPEEK(P,OF)`

==== RAM64K  

Syntax: `RAM64K` _page#_

NOTE: `RAM64K` is not available in {ecb}

The RAM64K statement tells the compiler that a full 64K of RAM is to be made available in the computer for variable storage etc. The compiler will automatically generate code to allow access to the upper 32K of ram during program execution. This normally unused 32K of memory can be used for any variable or array storage except for *Disk* related file buffers and *Fielded* variables. It is especially handy for large Arrays and string variable storage. This area of memory begins at address $8OOO and extends up to $FDFF, a total of 32,255 bytes of extra memory storage. 

[TIP]
To define variables in this area, it is best to use the `BASE` and `DIM` statements.

Examples:: `BASE=$8000` +
`DIM A1$(200,5O),A2$(50,255),AZ(1600)` +
`BASE=0000`

The preceding examples demonstrate how easy it is to  assign variables to the upper 32K of RAM. The two string arrays `A1$` and `A2$` occupy 28,750 bytes and the numeric array AZ occupys 3200 bytes of RAM. The `BASE` pointer is then restored to zero to allow any further variables to be assigned address space immediately following the program. 

The `RAM64K` statement for {cb} allows you to select any 32K bank of memory to be used in place of the upper 32K of memory where Basic normally resides. In the CoCo-3 you are normally in the *ALL RAM* mode and a modified image of the Basic ROM's is stored there and used for I/O calls and some other functions in a {cb} program. 

You can still use the upper portion of memory $8OOO-$FDFF for variable storage etc, but with a twist. You must tell {cb} what the starting page# is for the 32K bank of memory you want to use in the upper 32K area to replace the Basic ROM code. This means that you can select any 32K block of ram available in the machine to be access as the upper 32K, which gives you about 420K of storage space if desired. 

The _page#_ specified can be a number or variable in the range of 0-59 to select the starting 8K page (60-63 is the normal 64K being used). For example, if you wanted to select the *Extended Hi-Res Graphics* pages (320/640 * 192) which reside in memory from $60000-$67FFF (32K total) you would use a value of 48 decimal or *$30* hex to start at *$60000* (8 blocks of 8K for each 64K). 

[TIP]
If you want to deselect the upper 32K of memory to the normal ROM image use, `RAM64K 60`.

Examples::  `RAM64K 48` +
`RAM64K $30` +
`RAM64K 255` *Note: This last one does nothing useful.*

==== RAM ON/OFF 

*Syntax* : `RAM` <ON/OFF> 

The `RAM` statement allows manual control of the upper 32K of memory space address mode. The `RAM ON` statement, switches the Basic ROM's off and enables access to the upper 32K of RAM (normal CoCo-3 mode) which normally contains a modified image of the Basic ROM's. The `RAM OFF` statement does just the opposite, it disables the upper 32K of RAM and enables the Basic ROM's to occupy the upper 32K of address space. 

These two statements can be useful when `RAM64K` is not being used and access to some part of the Basic ROM's is needed, you simply enable the ROM's with a `RAM OFF` statement and when finished, restore to the `RAM64K` mode by using a RAM ON statement. These statements can be used whether or not the `RAM64K` statement has been used to allow accessing these areas of memory. When using the `RAM ON/OFF` option, it is necessary to either mask interrupts with the `IRQ ON` statement or provide `ON IRQ` and `ON FIRQ` interrupt handling.

==== LPCOPY 


*Syntax* : `LPCOPY` _source_{nbsp} TO _destination_ 

[NOTE]
Not available in {ecb}

The `LPCOPY` statement is used to copy the contents of any 8K page (0 - 63) of memory to any other 8K page (0-63). The "source" and "destination" are numeric constants or expressions between 0 and 63 specifying memory pages. This can be very handy for swaping info to and from the Extended Graphics screens which are normally not accessable. 

Examples:: `LPCOPY 1 to 48` + 
`LPCOPY AX to AY` 

The first example would copy the 8K block on page 1 (02000-03FFF) to page 48 (60000-61FFF).  The second example  demonstrates the use of variables to specify source and destination pages.

=== Hi-Res Text Screen Statements

==== WIDTH

*Syntax* : `WIDTH` _value_

The `WIDTH` command sets the text screen resolution to either 32 (32 * 16), 40 (40 * 24) or 80 (80 * 24).

Example :: `WIDTH 80`

==== LOCATE 

*Syntax* : `LOCATE` _(x,y)_ 

The `LOCATE` command allows you to position the cursor to any column (x) and line (y) position on the 40 or 80 column text screens. When used on a `WIDTH 40` screen, the x position can be 0 to 39. When used on a `WIDTH 80` screen, the x position can be 0 to 79. On either screen the y position can be 0 to 23. 

Example:: `LOCATE (3,10)` + 
`LOCATE (X,Y)`

==== ATTR 

*Syntax* : `ATTR` _foreground_, _background_,_Blink_,_Underline_ 

The `ATTR` or *Attributes* command allows you to select the foreground (Character) and background colors for the `WIDTH 40` and `WIDTH 80`  text display modes. These can be in the range of 0-15 to select a pallette color. Optionally you can select if the characters are to be Blinking and/or Underlined by following the foreground/background colors with the letter "B" for Blinking or "U" for Underlining. Attributes stay in effect until the next `ATTR` command is executed.

Example:: `ATTR 3,2,U` +
`ATTR F,B,B`

* 1st example will underline
* 2nd example will blink


==== HSTAT 

*Syntax* : `HSTAT` _vl,v2,v3,v4_

The `HSTAT` command is used to get information about the 40 or 80 column text screen cursor position. The values returned in the
variables are:

[width="50%",align="center"]
[cols="10,90"]
[frame=none,grid=none]
|===
|v1  | character code  
|v2  | character attribute
|v3  | cursor *x* coordinate
|v4  | cursor *Y* coordinate
|===

Example:: `HSTAT A,B,C,D`

<<<

=== Low Resolution Graphics & Sound

In the description of the following Low Resolution Graphics Statements the notations:

c::  refers to a numeric constant or expression in the range of 0 to 8 and represents a specified Color for the Low Resolution Text Display.

x:: refers to a numeric constant or expression in the range of 0 to 63 and represents the X coordinate (horizontal position) on the Low Resolution Text Display.

y:: refers to a numeric constant or expressing in the range of 0 to 31 and represents the Y coordinate (vertical position) on the Low Resolution text Display.


==== CLS

*Syntax* : `CLS` or `CLS(`_x_`)`

The `CLS` statement is used to clear the Low Resolut ion Display Screen to a specified color "c". If a color is not specified, Green is used by default. If the `HIRES` statement has been used to include the Hi-Resolution Display package, a `CLS` statement without a color will cause the Hi-Res Text Screen to be cleared.

Examples:: `CLS` +
`CLS(2)` +
`CLS(N)`


==== SET

*Syntax* :  `SET (`_x,y,c_`)`

The `SET` statement is used to set a graphics dot at a specified Text Screen location to a specified color. The _x,y_ coordinates can range from O to 63 and 0 to 31 respectively, and the color specified can range from O to 8. Any one or all the arguments can be a constant or variable expression.

Examples:: `SET(l4,13,3)` +
`SET(x,y,4)`


==== RESET

*Syntax* : `RESET(`_x,y_`)`

The `RESET` statement is just the opposite of the `SET` statement. It is used to reset or clear a point on the Low Resolution Text Screen. The _x,y_ coordinates can be a constant or variable the same as the `SET` statement.

Examples:: `RESET(14,4`) +
`RESET(x,y)`




==== POINT

*Syntax* : `POINT(`_x,y_`)`

The POINT statement is used to test whether a specified Graphics cell on the Text Display is on or off. The x,y coordinates can be a constant or variable expression the same as the SET & RESET statements. The value returned is -1 if the cell is in a Text Character mode, 0 is returned if it is off, and the color code 1-8 is returned if it is on.

Examples::  `POINT(x,y)` +
`POINT(14,4)`



==== SOUND

*Syntax* : `SOUND`_tone,duration_

The `SOUND` statement allows you to generate a sound thru the TV speaker with a specified tone for a specified duration of time.  The tone and duration can be either constants or variable expressions in the range of 1 to 255.



Examples:: `SOUND 123,3` +
`SOUND T,D`

<<<
=== Medium Resolution Graphics & Play

The Medium Resoulution Graphics statements in {cb} are almost identical to those in {ecb}. Some brief descriptions of the statements are given to show differences and examples of their usage. For more information on these statements and graphics refer to the {ecb} Manual. In the description of the following Medium Resolution Graphics Statements the notations:

x:: specifies the X-coordinate (horizontal position) on the graphics display area and is a numeric constant or expressing from 0 to 255.

y:: specifies the Y-coordinate (vertical position) on the graphics display area and is a numeric constant or expressing from 0 to 191.

c:: specifies an available color code and is a numeric constant or expression from 0 to 8. This is optional in many statements; if omitted, the foreground color is used.




==== PMODE

*Syntax* : `PMODE` _n,page_

The `PMODE` statement sets the graphics resolution and optionally the memory page to start on. The `PMODE` value ranges from 0 to 4 with 4 being the highest resolution mode (256*192).

The starting page "page" is a numeric expression or constant from 1 to 8, and specifies which 1.5K memory page you wish to start on. This is optional; and if omitted, the previously set page is used. If the `PMODE` statement is never used, the computer defaults to `PMODE 2,1`. 

[NOTE]
For more information see the Extended Color Basic Manual.


Examples:: `PMODE 4,1` +
`PMODE 3,P` +
`PMODE 4`


==== COLOR

*Syntax* : `COLOR` _foreground,background_

The COLOR statement allows you to change the graphics foreground and background colors (within the available choices). The "foreground" and "background" colors are numeric constants or variable expressions from O to 8, and represent the color codes.

Examples:: `Color 5,7` +
`COLOR 7,5` +
`COLOR FG,BG`

<<<
==== SCREEN

*Syntax* : `SCREEN` _type,color_

Screen is used to switch between text and graphics modes. The color option is used to switch between the two color modes.

[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|TYPE | RESULT

|0  | Text mode
|1  | Graphics mode
|===

[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|COLOR | RESULT

|0| Color Set 0
|1|  Color Set 1
|===


Examples:: `SCREEN 1,1` +
`SCREEN 1,0` +
`SCREEN 0,1`


==== PSET

*Syntax* : `PSET` _x,y,c_

The `PSET` statement is used to set a single point on the graphics screen to a specified color. The x and y coordinates are used to specify exactly which position on the screen you want to set. The _c_ argument is used to specify the color the dot on the screen will have.


Examples:: `PSET(0,0,8)`+
`PSET(l28,96,8)` +
`PSET(Xl,Yl,8)`

[NOTE]
The first example will set a dot in the top left corner of the screen and the 2nd example sets a dot in the center. The third example uses variables for the x,y coordinates.


==== PRESET

*Syntax* : `PRESET(`_x,y_`)`

The `PRESET` statement does the exact opposite of the `PSET` statement. It "resets" a dot in the screen to the background color. The _x_ and _y _arguments are used to specify exactly which dot on the screen is to be reset. 

[TIP]
You don't have to specify the color with PRESET since the computer automatically uses the background color.

Examples: `PRESET(l28,96)` +
`PRESET(Xl,Yl)`

[NOTE]
The first example will reset the dot at the center of the screen and the second example demonstrates the use of variables for the coordinates.

==== PPOINT 

*Syntax* : `PPOINT(`_x,y_`)`


The `PPOINT statement is similar in form to the `PRESET` statement, but instead of reseting the specified dot screen, it tests the color of a specified graphics point. Your program may then use the information any way you choose.

The `PPOINT` statement returns a value from O to 8 to represent color of the specified graphics point.

Examples: `C=PPOINT(l28,96)` +
`IF PPOINT(Xl,Yl) = 8 THEN 500`

[NOTE]
The first example will get the value of the color from the point in the center of the screen and assign that value to the variable `C`. The second example demonstrates the use of `PPOINT` in an `IF/THEN` statement, that is testing to see if the point at location `Xl`,`Yl` is orange in color and if so, it will transfer control to line `500`.

==== PCLS

*Syntax* : `PCLS` _color_

The `PCLS` statement is used to clear the graphics screen to a specified color 0-8. If a color is not specified, the screen will be cleared to the background color. This serves the same function for Hi-Res graphics as `CLS` does for the text screen.

Examples:: `PCLS` +
`PCLS 6`

[NOTE]
The first example would simply clear the screen to the background color. The second example would clear the screen with the color "cyan• (color code 6).

==== LINE

*Syntax* : `LINE(`_x1, y1`)-(`_x2,y2_`)`_,a,b_

The `LINE` statement is used to draw a line, box or rectangle on the graphics screen. The _x1,y1_ coordinates are used to specify the starting point on the screen and the _x2,y2_ coordinates are used to specify ending point for the line. The line is then drawn by the computer between these two points. 

The _a_ argument is used to tell the computer whether to draw the line using the pre-specified foreground color (PSET), or to use the pre-specified background color (PRESET). The `PRESET` function may be compared to "erasing" rather than drawing on the screen, since the background color makes the line invisible.

The _b_ argument is an option that allows you to draw a "Box" or rectangle without having to draw four separate lines. All you have to do is specify two of the opposing corners for the square in _x1,y1_ and _x2,y2_, and add `,B` to the statement. You also have the option to add an _F_ to the optional argument `,B` to produce `,BF`. This will let you "fill" the box with the foreground color to produce a solid box.

Examples:: `LINE(0,0)-(255,191),PSET` +
`LINE(64,48)-(96,64),PSET,BF`

[NOTE]
The `LINE` statement is used to draw a line, box or rectangle on the graphics screen. The _x1,y1_ coordinates are used to specify the starting point on the screen and the _x2,y2_ coordinates are used to specify ending point for the line. The line is then drawn. The first example will draw a line from the top left corner of the screen to the bottom right corner. The second example will draw a rectangle 32 points across and 16 points down in the middle of the screen and fill the box with the foreground color.

==== PCOPY

*Syntax* : `PCOPY` _source_ `TO` _destination_

 The PCOPY statement is used to copy graphics content of one memory page to another. The "source" and "destination" are numeric constants or expressions between 1 and  8 specifying memory pages.

Examples:: `PCOPY 3 to 8`  + 
`PCOPY AX to AY`

[NOTE]
The first example would copy the graphics on page 3 to page 8. The second example demonstrates the use of variables to specify the source and destination pages.


==== PAINT

*Syntax* : `PAINT(`_x,y_`)` , _color_ , _border color_
 
The `PAINT` statement allows you to "paint" any shape with any available color. The _x,y_ coordinates are used to specify where on the graphics screen the painting is to begin. 

The "color" parameter specifies the color code of the paint 0-8. 

The "border color" parameter tells the computer the color code of the border at which the painting is to stop. If the computer reaches a border other than the specified color, it will paint over that border.

_Example_

[source,bbcbasic]
----
10 PMODE 3,1
20 PCLS
30 SCREEN 1,1
40 CIRCLE(l28,96),90
50 PAINT(l28,96),8,8
60 GOTO 60
----

[NOTE]
The sample program will draw a circle in the center of the screen and paint in orange.

==== CIRCLE

*Syntax* : `CIRCLE(` _x ,y_ `)` , `r` , _[color],[hw ratio],[start],[end]_

The `CIRCLE` statement will allow you to create a full circle, a partial circle or an ellipse using a single Basic statement.

The only arguments required to make a circle are the center point coordinates _(x,y)_ and a radius "r", all other arguments are optional. The radius "r" specifies the circle's radius in units from 0 to 255, each unit of measurement is equal to one point on the screen. 

The optional "color" specifies an available color 0-8, default is the foreground color. 

The height/width ratio "hw" is optional, it specifies the ratio or the circle's "width" to it's "heigth", if not specified, a value of 256 is used (1:1). A value less than 256 results in a circle "wider" than it is high, a value over 256 results in a circle "Higher" than it is wide.

The start & end options allow you to draw just part of a circle (an arc). To use this option, specify the point where the arc is to begin (0-255), insert a comma, and then the point where it is to end (0 - 255). The starting point (0) for any circle is equivalent to 3 o'clock on a clock, 64 would be 6 o'clock, 128 would be 9 o'clock and 192 would be 12 o'clock. To use the start and end options, you must specify the "hw" ratio, for a normal arc, use *hw=256*. 

[TIP]
For more information on the CIRCLE statement, refer to the Extended Color Basic Manual.

Examples::  `CIRCLE(128,92),95` +
`CIRCLE(128,92),30,1,256,64,192` +
`CIRCLE(X1,Y1),30,1,HW,ST,EN`

[NOTE]
The first example demonstrates a simple circle drawn at the center of the screen. The second example demonstrates the use of all options to draw a half circle from 6 o'clock (64) to 12 o'clock (192). The last example is similar except some variables are used instead of constants.

[WARNING]
Please note that the "hw", "start" and "end" arguments in {cb}differ from those in Color Basic since they are fractional numbers. If these items are specified as constants in the `CIRCLE` statement the normal Color Basic decimal format will be accepted by the compiler. When variables are used, the values assigned to the them must conform to the specifications listed above for "hw", "start" and "end".

==== DRAW

*Syntax* : `DRAW` _expression_

The `DRAW` statement is used to draw a line or series of lines, by specifying its direction, angle, and color. The string expression may be a "literal", string variable or expression used to contain the `DRAW` statement commands. The `DRAW` commands are as follows:


[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|MOTION | 

|M | Move the draw position
|U | Up
|D | Down
|L | Left
|R | Right
|E | 45 degree angle
|F | 135 degree angle
|G | 225 degree angle
|H | 315 degree angle
|X | Execute a substring & return
|===

[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|MODE | 

|C  | Color
|A  | Angle
|S  | Scale
|===


[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|OPTION | 

|N | No update of draw position
|B | Blank (no draw, just move)
|===

The Motion commands tell the computer where to start drawing on the screen _(Mx,y)_, which direction to draw in _(U,D,L,R,E,F,G,H)_, and how many dots to draw _(U25,D25,E30,.. etc.)_. The motion command _Mx,y;_ positions the cursor to a specified _x,y_ point on the screen, to avoid unwanted lines on the screen preface the "M" command with the letter "B" as in;  `BM 128,96`. The "M" command can also specify a position "relative" to the current _x,y_ position by preceding each of the coordinates with a "+" or "-" sign; `BM+15,-15`.

The Mode command "Cx" allows you to specify a color code 0-8 to be used while drawing `C7`.

The Mode command "Sx" allows you to "scale" a drawing up or down, where x is a number from 1 to 62 to indicate the scaling factor in 1/4 units.  A scale of 4 = full scale 4/4, a scale of 1 = 1/4 scale, a scale of 8 = double scale 8/4 and so on up to 62.

After an "Sx" command, all motion commands will be scaled accordingly until the next "Sx" command.

The Mode command "Ax" allows you to specify the angle at which a line is to be drawn, 0 = 0 degrees, 1 = 90 degrees, 2 = 180 degrees, and 3 = 270 degrees.  All lines drawn following an Ax command will be drawn relative to the angle displacement specified by Ax.


The option "B" blank, has already been mentioned in relation to the Move command. It can also be used to prescede any motion command to cause a blank line to be drawn. This only affects the line immediately following the "B" blank option.

The option "N" can be used to tell the computer •not" to update the _x,y_ location after drawing a line, but to return to the current _x,y_ location before doing the next command. This only affects the conuuand immediately following it. 

The last Motion command "X" allows you to execute  another DRAW string assigned to the string variable immediately following the command (XA$. The computer will execute this DRAW string and then return to the next command following.

Examples:: `DRAW "BM128,96;E25;F25;G25;H25"` +
`DRAW A$`

[NOTE]
The first example moves the draw position to the center of the screen 128,96 and draws a box. The second example shows the use of a string variable for the DRAW string. For more information and examples of using the DRAW statement refer to the Extended Color Basic Manual chapter 7.


==== GET & PUT

*Syntax* : `GET` _(xl,yl)-(x2,y2), destination, G_  &  `PUT` _(xl,yl)-(x2,y2 ), source, option_

The `GET` and `PUT` statements are used to "get" a rectangular area which contains a graphics display, store it in an array, then "put" the array back on the screen at a later time. The _xl,yl_ and _x2,y2_ coordinates are used to tell the computer where the upper left corner and lower right corner of the rectangular graphics area is located on the screen to `GET` or `PUT`. 

The "destination" for `GET` is the name of a pre-defined numeric array that will be used to store the rectangle's contents. The "G" parameter for GET is optional, but if used specifies that the rectangle will be stored in the array with "Full GRAPHIC" detail.

The "source" parameter for the `PUT` statement is the name of a pre-defined numeric array that contains the data or previously stored `GET` rectangle, that is to be written to the display. The "options" for the `PUT` statement determine how the data is to be written to the display. They consist of the following:

PSET:: Set each point that is set in the source array.
PRESET:: Reset each point that is set in the source array.
AND:: Logically AND each point in the array with each corresponding point in the destination rectangle. If both points are set then the screen point will be set, otherwise reset.
OR:: Logically OR each point in the array with each corresponding point in the destination rectangle. If either point is set then the screen point will be set.
NOT:: Reverses the otate of e ach point in the destination rectangle reguardless of the PUT arrays contents.

[NOTE]
Before using the GET or PUT statements, an array must be defined to store the graphics data. The size of the array is determined by the size of the display rectangle. It must be large enough to hold all the data, but not too large, or memory space will be wasted. Since {cb} uses 2 byte integer variables for storage, it is easy to determine how large an array is r equired to hold the data. First, you must obtain the length and width of the rectangle by subtracting _x2_ from _x1_ and _y2_ from _y1_. Divide the _X_ value by 16 and rounding up to the next higher even number and then add 2.  Finally, you would then multiply that result by the _y_ value. The result the number of elements for the array. You can use either a one or two dimensional array.


[TIP]
If a graphics rectangle is 40 by 20, you have 40/16=2.5 rounded up equals 4. Multiplied by 20 for the y value gives a total of 80 elements. This is the number of elements for the array DIM X(50). If we had a large rectangle 180 by 125, this give s us 180/16=12 (rounded up) and 12 * 125 equalsl500 elements. You could use a (12,125) array or a one dimensional array of 1500.

There are several other ways to figure out the dimension size, this is just a simple straight forward way that seems to always work.

[CAUTION]
If you use the "G" option in a GET statement, you must use one of the options available for PUT or "garbage" will appear when you put the rectangle back on the screen. For more information on GET and PUT see t he Extended Color Basic Manual chapter 8.

_Example_

[source, bbcbasic]
----
10 DIM X(80)
20 GET (10,10)-(30,30),X,G
30 PCLS
40 PUT (100,100)-(120,120),X,PSET
50 GOTO 50
----

[NOTE]
The sample program simply "gets" the 20 by 20 rectangle from the screen and stores it in array x. It then clears the screen and "puts" the rectangle at a different location on the screen.

==== PLAY

*Syntax* : `PLAY` _expression_

The `PLAY` statement allows you to play music thru the speaker in the TV set. It allows you to control the notes, octave, volume, note length, tempo, pauses, sharps, flats and allows execution of substrings. These functions are controled with the following commands.


Notes:: A letter from "A" thru "G" with the a "+" or "#" to denote a sharp note and "-" to denote a flat note.
Optionally the numbers 1 thru 12 can be used to represent the notes: C, C#/D-, D/E-, E-/D#, E/F-, F/E#, F#/G-, G, G#/A-, A, A#/B-, B respectively.

Octave:: The letter "0" followed by a numeral from 1 to 5 is used to represent the octave. If omitted, octave 2
is used. The higher the value the higher to notes will be.


Note-length::  The letter "L" followed by a numeral from 1 to 255 is used to represent the note length. If omitted,
the current length is used. The value represents the length of the note as follows: 1=whole note, 2=1/2 note, 4=1/4 note, etc...

Tempo:: The letter "T" followed by a numeral from 1 to 255 is used to represent the tempo. If opmitted, T2 is
used. The higher the value the faster the tempo will be.

Volume:: The letter "V" followed by a numeral from 1 to 31 is used to represent the Volume. If omitted, V15
is used. The higher the volume will be.


Pause-length:: The letter "P" followed by a numeral from 1 to 255 is used to represent a pause. The values represent the length of the pause, l=whole note, 2=1/2 note, 4=1/4 note, etc...

Execute string:: The letter "X" followed by the name of the string variable is used to instruct the computer to "PLAY" the contents of the string variable and then continue in the present string.

Dotted notes:: The "Period" character". It is used following notes to instruct the computer to increase the length of  the note by one half of its normal value. If several "dots" are added to a note, each one will increase its note length by 1/2 its normal value.

Suffixes:: There are four suffix characters that can be used to alter the values for Octave "O", Volume "V",
Tempo "T" and Note length "L". The suffixes can be used to adjust the values of these commands without having to add numbers.

[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|OPTION | RESULT
|+  | Adds one the the current value.
|-  | Subtracts one from the current value.
|>  | Multiplies the current value by two.
|<  | Divides the current value by two.
|===

[TIP]
To increase the current tempo by one, you could use "T+", or to decrease the volume for a few notes you could use "V<" to lower it by half and
then use "V>" to restore it back to normal.

Example:: `PLAY "T1; V5; P2; VlO; A; P2; V20; A` +
`PLAY "XA$;XB$;XC$;XD$`

[NOTE]
The first example demonstrates a constant PLAY string that
simply plays a note and increases the volume. The second example
demonstrates the use of the Execute string command which is used
to PLAY several pre-defined play strings. For more information
and examples of using the PLAY statement, refer to the Extended
Color Basic Manual chapter 9.

<<<
=== High Resolution Graphics

The Extended Hi-Resoulution Graphics statements in {cb} are almost identical to those in Enhanced Color Basic. Some brief
descriptions of the statements are given to show differences and examples of their usage. For more information on these statements
and graphics refer to the Extended Color Basic Manual.

In the description of the following High Resolution Graphics Statements the notations:

x::  specifies the X-coordinant (horizontal position) on the graphics display area and is a numeric constant or expressing from 0 to 639.

y:: specifies the Y-coordinant (vertical position) on the graphics display area and is a numeric constant or expressing from 0 to 191.

c:: specifies an available color code and is a numeric constant or expression from O to 15. This is optional in many statements; if omitted, the foreground color is used.

==== HMODE

*Syntax* : `HMODE` _value_ [range: 0 - 4]

[WARNING]
This command is not available in Basic

The `HMODE` statement sets the graphics resolution the same as the `HSCREEN` conunand except that it does not perform a clear screen
when used. The `HMODE` value ranges from O to 4 with 4 being the highest resolution mode (640*192 2-color). For more information
see the Extended Color Basic Manual.

Examples:: `HMODE 4` +
`HMODE 2` +
`HMODE P`

[NOTE]
The first example sets the graphics mode to 4 (640*192 2-colors). The second example selects mode 2 which is 320*192 in
16 colors. The third example sets the mode to whatever the value of the variable P is at the time it is executed.


==== HCOLOR

*Syntax* : `HCOLOR` _foreground,background_ [range: 0 - 15]

The `HCOLOR` statement allows you to change the graphics foreground and background colors (within the available choices).
The "foreground" and "background" colors are numeric constants or variable expressions from 0 to 15, and represent the palette #.
 
Examples:: `HCOLOR 5,7` +
`HCOLOR 7,5` +
`HCOLOR FG,BR`

[NOTE]
The first two examples simply show constants being used for the foreground and background colors. The second example reverses
the foreground and background colors from the 1st example. The third example shows variables being used for the color codes.

==== HSCREEN

*Syntax* : `HSCREEN` _value_

The `HSCREEN` statement is used to select between the Text or Enhanced Hi-Res Graphics modes (320/640 modes). When this command
is used it will automatically clear the Hi-Res screen. If you don't want the screen to clear use the `HMODE` comman

Examples:: `HSCREEN 1` +
`HSCREEN 4` +
`HSCREEN 0`


==== HSET

*Syntax* : `HSET(` _x,y,c_ `)`

The HSET statement is used to set a single point on the graphics screen to a specified color. The _x_ and _y_ coordinates are
used to specify exactly which position on the screen you want to set. The _c_ argument is used to specify the palette color #.

Examples:: `HSET(0,0,8)` +
`HSET(l28,96,8)` +
`HSET(Xl,Yl,8)`

[NOTE]
The first example will set a dot in the top left corner of
the screen. The second example will set a dot in the center of
the screen. The third example demonstrates the use of variables
for the x,y coordinates.

==== HRESET

*Syntax* : `HRESET(` _x,y_ `)`

The `HRESET` statement does the exact opposite of the `HSET` statement. It "resets" a dot in the screen to the background
color. The _x_ and _y_ arguments are used to specify exactly which dot on the screen is to be reset. You do not have to
specify the color with HRESET since the computer automatically uses the background color.

Examples:: `HRESET(l28,96)` +
`HRESET(Xl,Yl)`



==== HPOINT

*Syntax* : `HPOINT(` _x,y_ `)`

The `HPOINT` statement is similar in form to the `HRESET` statement, but instead of reseting the specified dot on the screen, it tests the color of a specified graphics point. Your program may then use the information any way you choose. The `HPOINT` statement returns a value from 0 to 15 to represent the color Palette slot of the specified graphics point.

Examples:: `C=HPOINT(l28,96)` +
`IF HPOINT(Xl,Yl) = 8 THEN 500`

[NOTE]
The first example will get the value of the color from the
point in the center of the screen and assign that value to the
variable "C". The second example demonstrates the use of HPOINT in
an IF/THEN statement, that is testing to see if the point at
location X1,Y1 is orange in color, if so it will transfer control
to line 500.

==== HCLS

*Syntax* : `HCLS` _value_ [Range: 0 - 15]

The `HCLS` Statement is used to clear the graphics screen to a specified color 0-15. If a color is not specified, the screen
will be cleared to the background color. This serves the same function for Hi-Res graphics as `CLS` does for the text screen.

Examples:: `HCLS` +
`HCLS 6`

[NOTE]
The first example would simply clear the screen to the background color. The second example would clear the screen with the color "cyan• (color code 6).

==== HLINE

==== LINE

*Syntax* : `HLINE(`_x1, y1`)-(`_x2,y2_`)`_,a,b_

The `HLINE` statement is used to draw a line, box or rectangle on the graphics screen. The _x1,y1_ coordinates are used to specify the starting point on the screen and the _x2,y2_ coordinates are used to specify ending point for the line. The line is then drawn by the computer between these two points. 

The _a_ argument is used to tell the computer whether to draw the line using the pre-specified foreground color `PSET`, or to use the pre-specified background color `PRESET` . The `PRESET` function may be compared to "erasing" rather than drawing on the screen, since the background color makes the line invisible.

The _b_ argument is an option that allows you to draw a "Box" or rectangle without having to draw four separate lines. All you have to do is specify two of the opposing corners for the square in _x1,y1_ and _x2,y2_, and add `,B` to the statement. You also have the option to add an _F_ to the optional argument `,B` to produce `,BF`. This will let you "fill" the box with the foreground color to produce a solid box.

Examples:: `HLINE(0,0)-(255,191),PSET` +
`HLINE(64,48)-(96,64),PSET,BF`

[NOTE]
The `HLINE` statement is used to draw a line, box or rectangle on the graphics screen. The _x1,y1_ coordinates are used to specify the starting point on the screen and the _x2,y2_ coordinates are used to specify ending point for the line. The line is then drawn. The first example will draw a line from the top left corner of the screen to the bottom right corner. The second example will draw a rectangle 32 points across and 16 points down in the middle of the screen and fill the box with the foreground color.

==== HPAINT

*Syntax*: `HPAINT(` _x,y_ `)` _, color, border color_

The `HPAINT` statement allows you to "paint" any shape with any available color. The _x,y_ coordinates are used to specify where on the graphics screen the painting is to begin. The "color" parameter specifies the color code of the paint 0-15. The "border color" parameter tells the computer the color code of the border at which the pa:nting is to stop. If the computer reaches a border other than the specified color, it will paint over that border.

_Example_

[source, bbcbasic]
----
10 HMODE 3,1
20 HCLS
30 HSCREEN 1,1
40 HCIRCLE(128,96),90
50 HPAINT(128,96),8,8
60 GOTO 60
----

[NOTE]
The sample program will draw a circle in the center of the screen and paint in orange.


==== HCIRCLE

*Syntax* : `HCIRCLE(` _x ,y_ `)` , `r` , _[color],[hw ratio],[start],[end]_

The `HCIRCLE` statement will allow you to create a full circle, a partial circle or an ellipse using a single Basic statement.

The only arguments required to make a circle are the center point coordinates _(x,y)_ and a radius "r", all other arguments are optional. The radius "r" specifies the circle's radius in units from 0 to 255, each unit of measurement is equal to one point on the screen. 

The optional "color" specifies an available color 0-8, default is the foreground color. 

The height/width ratio "hw" is optional, it specifies the ratio or the circle's "width" to it's "heigth", if not specified, a value of 256 is used (1:1). A value less than 256 results in a circle "wider" than it is high, a value over 256 results in a circle "Higher" than it is wide.

The start & end options allow you to draw just part of a circle (an arc). To use this option, specify the point where the arc is to begin (0-255), insert a comma, and then the point where it is to end (0 - 255). The starting point (0) for any circle is equivalent to 3 o'clock on a clock, 64 would be 6 o'clock, 128 would be 9 o'clock and 192 would be 12 o'clock. To use the start and end options, you must specify the "hw" ratio, for a normal arc, use *hw=256*. 

[TIP]
For more information on the CIRCLE statement, refer to the Extended Color Basic Manual.

Examples::  `HCIRCLE(128,92),95` +
`HCIRCLE(128,92),30,1,256,64,192` +
`HCIRCLE(X1,Y1),30,1,HW,ST,EN`

[NOTE]
The first example demonstrates a simple circle drawn at the center of the screen. The second example demonstrates the use of all options to draw a half circle from 6 o'clock (64) to 12 o'clock (192). The last example is similar except some variables are used instead of constants.

[WARNING]
Please note that the "hw", "start" and "end" arguments in {cb}differ from those in Color Basic since they are fractional numbers. If these items are specified as constants in the `HCIRCLE` statement the normal Color Basic decimal format will be accepted by the compiler. When variables are used, the values assigned to the them must conform to the specifications listed above for "hw", "start" and "end".


==== HPRINT

*Syntax* : `HPRINT(` _x,y_ `)` _,String_

The `HPRINT` command allows you to print a text message on the Hi-Res (320/640 by 192) screen. The _x_ and _y_ positions are a column (0-39 for 320 modes or 0-79 for 640 modes) and a line position (0 to 23). The string is any valid string literal or variable up to the remaining character positions on the display.

Example:: `HPRINT (10,12),"HELLO"` +
`HPRINT (X, Y) ,A$`

[NOTE]
The first example will print "HELLO" at screen location X=10,Y=12. The last example is similar except some variables are used instead of constants.

==== HDRAW

*Syntax* : `HDRAW` _expression_

The `HDRAW` statement is used to draw a line or series of lines, by specifying its direction, angle, and color. The string expression may be a "literal", string variable or expression used to contain the `HDRAW` statement commands. The `HDRAW` commands are as follows:


[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|MOTION | 

|M | Move the draw position
|U | Up
|D | Down
|L | Left
|R | Right
|E | 45 degree angle
|F | 135 degree angle
|G | 225 degree angle
|H | 315 degree angle
|X | Execute a substring & return
|===

[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|MODE | 

|C  | Color
|A  | Angle
|S  | Scale
|===


[width="80%",align="center"]
[cols="20,80"]
[frame=none,grid=none]
|===
|OPTION | 

|N | No update of draw position
|B | Blank (no draw, just move)
|===

The Motion commands tell the computer where to start drawing on the screen _(Mx,y)_, which direction to draw in _(U,D,L,R,E,F,G,H)_, and how many dots to draw _(U25,D25,E30,.. etc.)_. The motion command _Mx,y;_ positions the cursor to a specified _x,y_ point on the screen, to avoid unwanted lines on the screen preface the "M" command with the letter "B" as in;  `BM 128,96`. The "M" command can also specify a position "relative" to the current _x,y_ position by preceding each of the coordinates with a "+" or "-" sign; `BM+15,-15`.

The Mode command "Cx" allows you to specify a color code 0-8 to be used while drawing `C7`.

The Mode command "Sx" allows you to "scale" a drawing up or down, where x is a number from 1 to 62 to indicate the scaling factor in 1/4 units.  A scale of 4 = full scale 4/4, a scale of 1 = 1/4 scale, a scale of 8 = double scale 8/4 and so on up to 62.

After an "Sx" command, all motion commands will be scaled accordingly until the next "Sx" command.

The Mode command "Ax" allows you to specify the angle at which a line is to be drawn, 0 = 0 degrees, 1 = 90 degrees, 2 = 180 degrees, and 3 = 270 degrees.  All lines drawn following an Ax command will be drawn relative to the angle displacement specified by Ax.


The option "B" blank, has already been mentioned in relation to the Move command. It can also be used to precede any motion command to cause a blank line to be drawn. This only affects the line immediately following the "B" blank option.

The option "N" can be used to tell the computer •not" to update the _x,y_ location after drawing a line, but to return to the current _x,y_ location before doing the next command. This only affects the conuuand immediately following it. 

The last Motion command "X" allows you to execute  another HDRAW string assigned to the string variable immediately following the command (XA$. The computer will execute this DRAW string and then return to the next command following.

Examples:: `HDRAW "BM128,96;E25;F25;G25;H25"` +
`HDRAW A$`

[NOTE]
The first example moves the draw position to the center of the screen 128,96 and draws a box. The second example shows the use of a string variable for the DRAW string. For more information and examples of using the DRAW statement refer to the Extended Color Basic Manual chapter 7.

==== HGET & HPUT

*Syntax* : `HGET` _(xl,yl)-(x2,y2), destination, G_  +
  `HPUT` _(xl,yl)-(x2,y2 ), source, option_

The `HGET` and `HPUT` statements are used to "GET" a rectangular area which contains a graphics display, store it in a buffer, then "PUT" the buffer back on the screen at a later time. The _xl,yl_ and _x2,y2_ coordinates are used to tell the computer where the upper left corner and lower right corner of the rectangular graphics area is located on the screen to `HGET` or `HPUT`. 

The "destination" for `HGET` is the name of a pre-defined `HBUFF` that will be used to store the rectangle's contents. 

The "options" for the `HPUT` statement determine how the data is to be written to the display. They consist of the following:

PSET:: Set each point that is set in the source buffer.
PRESET:: Reset each point that is set in the source buffer.
AND:: Logically AND each point in the buffer with each corresponding point in the destination rectangle. If both points are set then the screen point will be set, otherwise reset.
OR:: Logically OR each point in the buffer with each corresponding point in the destination rectangle. If either point is set then the screen point will be set.
NOT:: Reverses the state of each point in the destination rectangle regardless of the HPUT buffers contents.

[NOTE]
Before using the HGET or HPUT statements, an buffer must be defined to store the graphics data. The size of the buffer is determined by the size of the display rectangle. It must be large enough to hold all the data, but not too large, or memory space will be wasted. Since {cb} uses the same buffer area as Enhanced Color basic the calculations are the same, See page 173-175 in your {ecb} manual for more information.

[source, bbcbasic]
----
10 HBUFF 1,43
20 HGET (10,0)-(20,10),1
30 HCLS
40 HPUT (100,100)-(110,110),1,PSET
50 GOTO 50
----


[NOTE]
The sample program simply "GETS" the 10 by 10 rectangle from the screen and stores it in buffer 1. It then clears the screen and "PUTS" the rectangle at a different location on the screen.

==== HBUFF

*Syntax* : `HBUFF` _value_

The `HBUFF` command is used to reserve memory space to store a rectangle of graphics information for the `HGET` & `HPUT` Statements. The buff# is a number that labels the buffer for use with `HGET` or `HPUT` Statements and the size is the number of bytes to reserve.

For more information on determining the size for the `HBUFF` command see the {ecb} manual, page 173.

Example:: `HBUFF 1,43`

==== BORDER

*Syntax* : `BORDER` _value_

The `BORDER` command allows you to select a pallette number 0-15 for use as the BORDER color on the screen. You can change colors for the border at any time. Normally the Border color is selected the same as the background color when a `HCLS` command is executed. The `BORDER` command allows you to select a new color without having to clear the screen.

Example:: `BORDER 14`

==== PALLETTE

*Syntax* : `PALETTE` _reg#, color_ +
`PALETTE RGB` +
`PALETTE CMP` +
`CMP` +
`RGB` 

The `PALETTE` command is used to select any of the available 64 colors for a specified palette register (0-15) number. If `RGB` or `CMP` follows the `PALETTE` command it will cause the default colors for an RGB monitor or Composite monitor to be used. The `RGB` or `CMP` commands can also be used by themselves to obtain the same results.

Example:: `PALETTE 3,44` +
`PALETTE CMP` +
`PALETTE N,C`

<<< 

=== Screen, Printer and RS-232 I/O

==== INPUT

*Syntax* `INPUT` _var, var,... , var_ +
`INPUT` _"literal string" ; var,... , var_ +
`INPUT` _#N, var, var,... , var_

The INPUT statement causes code to be generated which displays a "?" prompt and space on the screen or RS-232 device. It then reads characters into the input buffer until 255 characters have been read or an ENTER or BREAK key depressed. A carriage return is output to the screen or RS-232 device when the last character is input. During the entry of data, each character input is echoed back to the screen or RS-232 device.

At run-time, entry of a shift/left arrow will delete the current buffer contents. A left arrow will backspace the cursor and erase the character.

If a "literal string" immediately follows the INPUT statement, that string of characters will be displayed on the screen or RS-232 device before the "?" prompt.

The variables specified may be numeric or string, subscripted or simple type. When the program is "looking for" a number from the current position in the input buffer, it will skip leading spaces, if any, and read a minus sign (if any), and up to five number characters. The numeric field is terminated by a space, comma, or end of line. If a non- digit character is read or any other illegal condition, a value of zero will be returned for the number. The symbols "$" and "&H" may also be used to input hexadecimal numbers directly.

If a string-type field is being processed, leading spaces will be skipped unless enclosed within quotes "" and data accepted, until the variable field is terminated by a comma, end of line, ending quote, or when the string variable is "full". If no characters are available, a null string will be returned.

The INPUT statement may also be followed immediately by the "#" pound symbol and a device number or numeric variable. When doing input from a device such as Tape or Disk, the file must have been previously "opened" by the `OPEN` statement, or an error will occur. This condition is detectable by the `ON ERROR GOTO` statement. For more information on device I/O see the section on TAPE & DISK I/O.

Examples:: `INPUT A,B,AX$,RA$(N)` +
`INPUT 1-1, A$,N,A(4,N)` +
`INPUT "Enter your narne";NA$`+
`INPUT 1-3,"Enter your narne";NA$` +
`INPUT IN,A$,B$,C,D` +
`INPUT N`

==== LINEINPUT

*Syntax* : `LINEINPUT` _string variable_ +
`LINEINPUT` _"literal string"; string variable_ +
`LINEINPUT` _#N, string variable_

The `LINEINPUT` statement is almost identical to the standard `INPUT` statement, except it assigns the entire contents of the input buffer to a string variable, including commas, spaces and quotes. Only one variable name may be listed since any following variables will be assigned a null string. When used for keyboard or RS-232 input, it will not display the "?" prompt.

As in the standard INPUT statement a "#" pound sign followed by a device number or numeric variable may be used immediately following the statement to direct input from tape, disk or the RS-232 port.

Examples::  `LINEINPUT A$` +
`LINEINPUT "Enter your full name";NA$` +
`LINEINPUT 1-1, AX$` +
`LINEINPUT 1-3, "Enter your Name ";NA$`

==== PRINT

*Syntax* : `PRINT` +output spec(,;]... output spec_ +
`PRINT @N` _,output spec(,;] output spec_ +
`PRINT #N` _,output spec(,;]... output spec_

The `PRINT` statement is used to output information to the screen, printer, RS-232 port, tape or disk. The output spec's are processed and the appropriate characters are put in the I/O buffer. The buffer is then output to the proper device.

The output spec's may consist of string or numeric expressions, or the output function TAB(expr) which inserts spaces in the buffer until the position "expr" is reached. Each item in the list is separated by a delimiter which is either a comma or semicolon. The buffer is divided into thirty-two 8 character zones, which are effectively tab stops every eighth position. If a comma is used as a delimiter, the next item will begin at the first position of the next zone. 

If a semicolon is used, NO spacing will occur. A semicolon at the end of a `PRINT` statement will inhibit the printing of a carriage/return at the end of the line. A `PRINT` statement without any output spec's will produce a carriage return only.

The `PRINT` statement can optionally be followed by the "#" pound sign and a number or numeric variable to direct out put to a device other than the screen. If output is attempted to tape or disk, a file must have been previously "opened" for output or an error condition will occur. This can be detected at run- time by the `ON ERROR GOTO` statement. For more information refer to the section on TAPE & DISK I/O.

The `PRINT` statement can also be followed by the "@" symbol and a number or numeric variable to print at a specified location on the screen. If the standard screen is being used, the highest location available is 511 (32 by 16). If the HIRES option was used in the program, the highest location can vary from 671 to as high as 6119 depending on the selected line length.

Examples:: `PRINT A,B,C` +
`PRINT A$(N),A$(N+l)` +
`PRINT #-2, A,A$,B,B$,NA$` +
`PRINT #-3, "Hello ";NA$` +
`PRINT @12,"Hello ";NA$` +
`PRINT #N, A$;TAB(N+M);BA$`

==== INKEY

*Syntax* : `INKEY` _<numeric var.>_ +
`INKEY$` _<string var.>_

{cb} allows the use of an `INKEY` type function to return a numeric value or a string value. This can be very helpful in evaluating data returned to represent a key pressed, since it is normally converted from a string to a numeric value before processing. It also requires much less code to evaluate a numeric value in an `IF/THEN` statement, than to evaluate a string argument. It also generates less code and executes faster than doing an `INKEY$` function.

_Example_

[source, bbcbasic]
----
100 A = INKEY
200 IF INKEY=13 THEN 500 ELSE 200: REM WAIT FOR ENTER
----

==== RS-232 PORT - Additional Support

With {cb} there is Device #-3 support for:

`INKEY #-3` +
`INPUT #- 3` +
`PRINT #-3` +
`INKEY$ #-3` +
`LINEINPUT #-3` 

{CB} supports the RS-232 port on the back of the Color Computer for input and output, using standard basic commands and functions.

All commands work the same as they do normally except for the `INKEY` and `INKEY$` functions. When an `INKEY` type function is executed on the RS-232 port (device #-3), it will scan the port for input for approximately 2 seconds waiting for a character. If no character is received within that time limit a 0 or null string value is returned. If received data is available it will return the data as soon as a full character is received.

Examples:: `INPUT #-3,` _variable list_ +
`PRINT #-3,` _variable list_ +
`A=INKEY #- 3`

==== Printer & RS-232 Baud rate

*Syntax* : `BRATE =`  _baud rate_ +
`PRATE =` _baud rate_

These commands are used to set a desired Baud rate for the Printer `PRATE` or the RS-232 port `BRATE` from within a compiled {cb} program. The value must be a rate between 110 and 9600, variables or numeric expressions are not allowed. Valid baud rates are: 110, 300, 600, 1200, 2400, 4800 and 9600. A baud rate of 110 is not valid for use on the RS-232 port. If you are going to run the computer at double speed select a rate that is half the desired baud rate, ie. to select 4800 baud use `BRATE=2400`.

Examples:: `PRATE=9600` +
`BRATE=1200`

==== Position @

*Syntax* : `POS@`

The `POS@` function has been added to allow access to the current print @ position on the screen. It will return the current print @ position for either the standard 16*32 screen or the `HIRES` screen if the `HIRES` option was used. This can be handy when you wish to display a message on a different part of the screen than the current cursor location such as a status update and then return to the original cursor position for input or another display update.

_Example_

[source,bbcbasic]
----
100 A=POS@
110 PRINT @0, "TIME IS RUNNING OUT";
120 PRINT @A,"";
----

=== Character I/O Commands

==== PUTCHAR

*Syntax* : `PUTCHAR` _device#, #variable or value_

The `PUTCHAR` command allows you to send or write a single byte value of information to a specified device. You can use any numeric expression, variable or number for the value to be output.

The data will be output as a single byte to the device which means that only the least significant byte of a variable or expression will be used (0-255) with the most significant byte discarded.

This can be very useful for doing screen dumps or outputing binary data to a device or file. This command will allow you to overcome the {cb} limitation of not being able to send a null (00) character out as part of a string or string variable (00 is used as an end of string marker). Any legal device number can be used (-3 thru 9) to select where the output data will sent. If a device number is not specified the screen will be used (device O).

Exmamples:: `PUTCHAR #-2,A` +
`PUTCHAR #-2,PEEK(A+B)` +
`PUTCHAR DV,223`

==== GETCHAR

*Syntax* : `GETCHAR`  _device#, numeric variable_

The `GETCHAR` command allows you to get or input a single byte of information from a specified device. In some ways it is similar to the `INKEY` statement except that when used to get a byte from the Keyboard or Serial port it will wait until a byte is received or key pressed before continuing on to the next statement. The byte returned from the command is always stored in a numeric variable as a value between 0 and 255. 

For example if a `GETCHAR` command was used to input a value from the keyboard and the "A" key was pressed a value of 65 or $41 would be stored in the variable specified. It can also be useful to read binary information from a disk file or binary serial data from the RS-232 port such as in an XMODEM file transfer etc. If a device number is not specified it will default to the keyboard (device 0).

Examples:: `GETCHAR #-3,A` +
`GETCHAR B` 

=== Tape and Disk I/O

Disk and Tape I/O in {cb} is channel oriented meaning a file to be used for input or output must be "opened" and assigned a channel number by which all further operations on that file are performed. {cb} supports up to 9 Disk channels (l-9) and 1 tape channel (-1), which are maximum number of files that may be open at any time.

All disk and tape file names are defined the same as the normal Basic operating system's. All files used by {cb} are standard ASCII formatted data files.

Many of the {cb} disk and tape operations are the same as the normal Basic, so information as to disk and tape operations in the Basic Reference manuals will generally apply.

[NOTE]
In the descriptions of disk and tape statements that follow the term "file-id" refers to an 8 character file name. For disk files the 3 character extension and drive number may also be included. If a file extension is not included, a ".DAT" extension will automatically be assumed. If a drive number is not specified, it will default to drive #0.

The term "#F" refers to a channel number which may be a numeric constant or variable for reference to a specified disk channel, or tape. It is up to the programmer to make sure that any variable used for a channel number is within the correct range, and that the device has been previously "opened" by the `OPEN` statement. All errors are detectable at run-time by the `ON ERROR GOTO` statement. If an error should occur during disk or tape I/O and `ON ERROR` trapping is disabled, unpredictable results can occur.

[TIP]
Remember that Disk file buffers cannot reside in the upper 32K of memory space. You can determine this from the Variable table listed at the end of the program when compiled. Disk file buffers are shown as "#n" where n is the file number as used in the program. Fielded record buffers are shown as "*n" where n is the file number it is associated with in the program. If the address of the next variable is greater than 8000, it means that the associated disk buffer or record is in the upper 32K of memory space. If this condition exists you can use the `BASE` statement in the beginning of the program to assign variables in the upper 32K of memory and when you get to the first statement that references a disk file buffer, change the base back to zero. This will usually do the trick.

==== FILES

The `FILES` command is recognized by {cb} to avoid syntax errors and confusion when converting Color Basic programs to {cb}. Since {cb} dynamically allocates file buffers as files are created, the `FILES` command has no function and does not generate any program code. When encountered in a {cb} program, the `FILES` statement is treated the same as a `REM` statement.

==== AUDIO _ON/OFF_

The `AUDIO` _ON/OFF_ command is used to either connects or
disconnects the sound coming from the cassette tape recorder to the T.V. speaker. The `AUDIO` command must be followed by either the word `ON` to enable sound to the speaker, or `OFF` to disconnect the cassette sound from the speaker.

Examples:: `AUDIO ON` +
`AUDIO OFF`

==== MOTOR ON/ OFF

This command allows the user to manually turn the cassette
recorder motor either on or off under program control. Normally the cassette tape recorder is controled automatically when reading or writing tape files.

Examples:: `MOTOR ON` +
`MOTOR OFF`

==== OPEN

*Syntax* : `OPEN` _"I/O/R/D",#(1-9),"file-id",(record length)_ +
`OPEN` _"I/O",#-1,"file-id"_

The "OPEN" statement for Disk & Tape files is almost identical to the standard Basic Open command. Basic normally allows file numbers -2 and 0 to be used in association with Printer and Screen or Keyboard Input and Output. On a Disk System, the system allows file numbers between one and nine (1-9) to be used in association with disk files. These files can be opened for Input, Output, Direct, or Random access. Tape files (-1) can only be opened for sequential access, Input or Output only. If a disk file is opened for Input or Output, it can only be accessed in a sequential manner, examples of these would be text, program or cassette tape files. They must be either read or written to in sequence, and cannot be accessed in any other manner. Random or Direct access files can be read or written to in any portion of the file, and will be discussed in more detail further on in this manual.

The file id can be a string or string variable. For disk files, it must include a drive number if other than drive 0. The disk file type will default to a data file ".DAT". On disk files, a record length may be specified following the file-id for Random or Direct access files, if not a default record length of 256 bytes is used.

[CAUTION] 
With the OPEN statement,  the channel number "MUST" be a constant number in the range of 1-9 for disk, or -1 for tape.

Examples:: `10 OPEN "I",#2,"LABLES.TXT:1"` +
`210 OPEN"R",#1,"DATABS:2",128` +
`610 OPEN"I",#-1,"DATABASE"`

[NOTE]
The first example shows that a sequential input file (file #2) is to be opened on drive #1, and the file will be called "LABEL.TXT". The second example shows a Random access file (#1) will be opened on drive #2, and the file name is "DATABS.DAT" (it's record length is 128 bytes). The third example will open the Tape file "DATABASE" for input.

[TIP]
When a Random access file is opened and the file is not on the specified disk drive, or does not exist, a file will be created with no data in it. If a file is to be opened for Input and does not exist, an error will be reported. If a file is to be opened for Output and already exists on the disk, it will automatically be "KILLED" or Scratched and no warning or message will be displayed.

==== PRINT

*Syntax* : `PRINT` _#F,(VARIABLE LIST)_

The `PRINT` statement is used to output data sequentially to a disk or tape file buffer. It can be used for sequential or random access disk files (you may use a comma or semi-colon to format or separate each item). Normally when using the `PRINT` statement the dat a is output to the file in the same exact format as it would be output to the Screen or Printer. This includes spaces output by TAB functions or by commas, etc. This may not be exactly what you want if you plan to read the data back out of the file with an `INPUT` statement. Normally you would use the "WRITE" statement if you want data to be in this format. You can also make the PRINT statement work the same by using a "#number" instead of a # variable for the device number.

_Example_

[source, bbcbasic]
----
10 OPEN "0",#1,"NUMBER"
20 FOR I=1 TO 100
30 PRINT #1,I
40 NEXT I
50 CLOSE
----

[NOTE]
This example would write the numbers from 1 thur 100 to a disk file on drive 0 with the name "NUMBER.DAT". Each number would be separated by an "enter" character in the file. If a semi-colon were used following the "I" such as `PRINT #1,I;` , the numbers would be written with only a single space between each one. Also if a comma were used to separate two items such as `PRINT #1,I,I+1 ` , then there would be several spaces between "I" and "I+" followed by an "enter" character.

==== WRITE

*Syntax* : `WRITE` _#F,(VARIABLE LIST)_

The `WRITE` statement is used to output data sequentially to a disk file buf fer. It can be used for sequential or random access files (you may use a comma "ONLY" to separate each item). When using the `WRITE` statement the data is output to the file with delimiters between each item as it is written to the file. This is exactly what you want if you plan to read the data back out of the file with an `INPUT` statement. Normally you would use the "WRITE" statement if you want data to be in this format. The `WRITE` statement can be used with random access files by following each WRITE statement with a "PUT" statement (see GET & PUT for the format). If an attempt to write more data than the record buffer can hold is made an error will be reported. 

[NOTE]
The record buffer does "NOT" have to be Fielded when I/O is performed using `WRITE`, `PRINT` and `INPUT` in this format.

_Example_

[source, bbcbasic]
----
10 OPEN"0",#1, "DATA"
20 A$ = "JOHN SMITH"
30 B$ = "TEST DATA"
40 C = 9875432
50 WRITE #1,A$,B$,C
*55 PUT 11,1
60 CLOSE
----

[NOTE]
This example would write the data "JOHN SMITH", "TEST DATA"
and the number "9875432" to the disk file on drive to called
"DATA.DAT". Each item would be separated by a delimiter character in the file. *Line 55* is there to show how `WRITE` would be used to store data in a random access file.

==== INPUT

*Syntax* : `INPUT` _#F,(VARIABLE LIST)_ +
`LINE INPUT` _#F,(VARIABLE LIST)_

The `INPUT` statement like the `Write` and `Print` statements can be used to communicate with a sequential or random access disk file. The variable list is the same as the normal `INPUT` statement for Tape or Keyboard I/O. Each item in the variable list is separated by a comma, and can be mixed string and numeric variables as long as the input data from the disk file is the same type. Numeric data can be read into a string variable as long as it was not created using the `MKN$` function. The `LINE INPUT` command functions identically, except it will ingore delimiters such as commas, quotation marks and colons, Everything is accepted. (See the Extended Basic manual for further details).

_Example_

[source, bbcbasic]
----
5 DIM A(1OO)
10 OPEN "O", #1, "NUMBER"
20 FOR I=1 TO 100
30 WRITE #1,I
40 NEXT I
50 CLOSE #1
60 OPEN "I", #1 , "NUMBER"
70 FOR I=100 TO 1 STEP -1
80 INPUT #1,A(I)
90 NEXT
100 CLOSE
----

[NOTE]
The example shows a file being written with the numbers from
1 to 100, and then being Rewound (CLOSED & RE-OPENED for INPUT). The file is then read storing the data in the array "A(1OO)" in reverse order.


==== EOF

*Syntax* : `EOF(` #F `)`

The `EOF` function is used to determine whether the file number (#F) specified is at the End Of File during a read. It will return a value of 0 if there is more data to be read in the file, and a -1 if there is "no" more data. The `EOF` function should be used prior to every `INPUT` performed on a file, or an *IE* (Input Past End Of File) error will be reported when the end of file is reached. (See Color Basic manual for more information)

_Example_

[source, bbcbasic]
----
10 OPEN "I" , #1, "LABLES"
20 IF EOF(1) = -1 THEN 50
30 INPUT #1,A$,B,C$
40 PRINT A$,B,C$
45 GOTO 20
50 CLOSE #1
----

[NOTE]
The Example shows how the EOF function is used in a program
to test for an end of file condition prior to each INPUT command. If line 20 was not in the program an "IE" error would be reported when the end of file is reached.

==== CLOSE

*Syntax* : `CLOSE` _#F_ +
`CLOSE`

The `CLOSE` statement is used to terminate I/O between a Basic program and a disk, or tape file, whether for Input, Output or Random/Direct access. Closing a file will release the memory space used for the disk file sector buffer (FIB), and random access sector buffer if used. This statement can have two forms; one of which specifies a file number previously used in an `OPEN` statement to be closed and the second form is used without- any file number and specifies that all open files are to be closed.

It is very important to `CLOSE` files when communications is finished so that all information is written to the correct disk or tape file, and on the correct disk before it is removed from the drive (SEE Color Basic manual for further details).

Examples:: `150 CLOSE #1` +
`240 CLOSE`

==== ERR & ERNO

*Syntax* :  `ERR` + 
`ERRNO`

The `ERR` & `ERNO` functions works in conjunction with the `ON ERROR GOTO` statement. The `ERR` function allows access to the last error reported in general or on any active file number. See the example following the `ON ERROR GOTO` statement.

==== ERL & ERLIH

*Syntax* : `X=ERL` +
`X=ERLIN`

The `ERL` & `ERLIN` functions a l so works in conjunction with the `ON ERROR GOTO` statement. These functions allows access to the number of the line in which the last error occured. For `ERL` & `ERLIN` to function properly the `TRACE ON` function must be enabled. Otherwise these functions will return a value of zero.

==== ON ERROR & ON ERR GOTO

*Syntax* : `ON ERROR GOTO` _line#_ +
`ON ERR GOTO` _line#_

The `ON ERROR` & `ON ERR` statements allows the user to handle system errors without halting the current program execution, by passing control to a specified line number in the program to process the error. These functions can be changed at any time in the program to allow for a general error handling routine, or may be changed for a specific disk error handling not covered by the general error handler. If no error handling is specified, a normal basic error display & halt will occur. Error handling for any active file may be changed at any time or disabled by specifying a "GOTO" line number of "0". This can be used for disabling the general "ON ERROR" handling as well.

_Example_

[source, bbcbasic]
----
10 ON ERROR GOTO 300:TRACE ON
20 OPEN "I",  #1, "NAMES1"
300 PRINT "ERROR #":ERR;" IN LINE NUMBER " ;ERL
----

==== FIELD

*Syntax* : `FIELD` _#F, length `AS` var,.... , etc._

The `FIELD` command is used in conjunction with Random or Direct access files to format a disk record into specific fielded variables. By fielding a file record (buffer), the system associates specified areas in the disk file record to variables.

When fielding a record, the total length of the the fielded areas may not exceed the length of a single record as defined by the `OPEN` statement. Each time a `FIELD` statement is executed, the record is fielded starting at the first position of the record, therefore many different variables may be associated with the same area or overlapping areas in a record. The record may be fielded at any time during program execution, provided the associated file number is open for random or direct ("R" or "D") access. Once a variable has been fielded, its value will be whatever data is currently in the associated record buffer. When the data is changed by use of the "GET" statement, the variable data will also change according to the file contents.

When the `FIELD` statement associates a string variable with an record buffer in Color Basic, it can only be assigned data via the `RSET` or `LSET` statement. This is not the case in {cb}. Once a variable is assigned to a fielded record buffer it cannot be reassigned. Therefore in {cb} the "LET" or implied "LET" statement can be used on fielded variables. Since variables are assigned in fixed locations, you cannot use a previously fielded variable in another `FIELD` statement. You can however field a file record more than once, as long as successive `FIELD` statements use different variable names. Data can also be moved to a fielded variable by the use of the `LSET` or `RSET` statements. The following examples will show some methods for fielding a record.

_Example1_
[source, bbcbasic]
----
10 OPEN "R",#1,"TESTER.TXT",64
20 FIELD #1,32 AS A$,32 AS BS
30 FIELD #1,10 AS IT$,12 AS VN$,20 AS DI$,22 AS CO$
----

_Example2_
[source, bbcbasic]
----
10 OPEN #1,"R","TESTER.DAT",256
20 FIELD 11,20 AS FIRST$,20 AS LASTN$,40 AS ADORES$ ,
15 AS CITY$,2 AS STATE$,5 AS ZIP$,40 AS COMPANY$
----

[NOTE]
The first example shows how a file record can be fielded more
than once with different variables. The second example shows a
mailing record be defined and that the entire record length does not have to be fielded.

==== RSET & LSET

*Syntax* : `RSET` _var = expression_ +
`SET` _var = expression_

The `FIELD` statement has previously been used to assign a string variable name to a portion of the disk file record buffer.

These and other string variables can receive their data via the `RSET` and `LSET` commands so that the unused string storage will be filled with spaces. These comnunands store the result of a string expression into the variable space either right justifed (RSET) or left justified (LSET). If the transfered data lenght is less than the length of the variable space allocated, the unused spaces will be filled with "space" characters. If the transfered data is larger than the fielded variable it will be truncated or lost.

_Example_
[source, bbcbasic]
----
10 FIELD *l,10 AS A$,10 AS BS
20 LSET A$="TESTING"
30 RSET B$="FIELDSET"
40 LSET B$=STRING$(10,32)
----

Results:

 Location 1 2 3 4 5 6 7 8 9 10 "-" = SPACE
 A$ field T E S T I N G - - - LSET (LEFT JUSTIFIED)
 B$ field - - F I E L D S E T RSET (RIGHT JUSTIFIED)
 B$ field - - - - - - - - - - FILLED WITH SPACES


==== GET & PUT

*Syntax* : `GET` _#F,(RECORD #)_ +
`PUT` _#F,(RECORD #)_

The `GET` & `PUT` statements are used in conjunction with Random or Direct access files only. They tell the system to read or write the "next" or specified record# of the designated file. The correct disk sector is computed and read into the sector buff er if necessary. The correct portion of that sector information is then transferred to or from the file record buffer. Once there by the use of a `GET` statement, the data can be manipulated or transferred from a fielded variable or assigned to a different variable by the use of an `INPUT` or `LET` statements. If a `PUT` statement is executed, the record buffer is transferred to the disk file sector buffer and written to the disk when necessary. A variable can be used to specify the file and/or record number to `PUT` or `GET`. When no record number is specified, the next record number in sequence will be used. If an attempt is made to `GET` a record that is past the end of the file, an error will be reported. If an attempt is made to PUT a record past the end of file, the file will automatically be expanded to store the record with extra space allocated for future expansion. If no disk space can be obtained for file expansion, an error will be reported.

_Example_

[source, bbcbasic]
----
10 OPEN "R",#1,"DATA",128
20 INPUT"HOW MANY RECORDS TO INITALIZE";RECORD
30 REM INITALIZE SPECIFIED NUMBER OF RECORDS
40 FIELD #1,INITALIZE$ AS 128
50 LSET INITALIZE$="EMPTY RECORD"
60 PUT #1,RECORD:' ALLOCATE RECORD SPACE
70 FOR I = 1 TO RECORD
80 PUT #1,I
90 NEXT I
100 CLOSE #1
----

[NOTE]
This example shows a random file being opened and the
operator being prompted for the number of records that the file is to be initialized for, when input the highest record # is written first to expand the file. The rest of the records are then initialized in sequence via the for next loop until the highest record is re-written & the file closed.

==== CHAIN

*Syntax* : `CHAIN` _"file id.ext:drive",offset_

The `CHAIN` statement allows Machine Language Disk programs to be loaded and automatically executed. It is identical to the format of the Basic `LOADM` command. {cb} will allow any machine language program to be loaded and executed in this manner, even if it loads right over the currently executing program in memory. However, if a program has an I/O error after it has been partly loaded into memory, unpredictable results may occur. The file name can be any valid string expression and the offset can be either a number or numeric variable.

Examples:: `10 CHAIN "BIOIA"`
`349 CHAIN A$`

The first example shows the command being used with a literal
string to load and begin execution of the machine language program "BIOIA.;" from drive 0 (default). The second example shows it being used in a program statement line where the variable "A$" is being used to pass the drive and file id paramaters to the disk operating system.

==== KILL

*Syntax* : `KILL` _"file-id.ext:drive"_

The `KILL` statement is the same as the Basic Kill command only it must be used in a basic program. The `KILL` command can specify only a single file on a specified disk.

Examples:: `10 KILL "TESTER.DAT:2"` +
`50 KILL DF$` 

[NOTE]
The first example shows that the individual file called
"TESTER.DAT" will be removed from the disk on drive #2. The
second example shows the use of a string variable to specify the file to be removed.

==== RENAME

*Syntax* : `RENAME` _<old file-id>_ `TO` _<new file-id>_

The `RENAME` command is used to change the name of a specified file to a new name. If the Old file name does not exist or the New file name is already being used an error will be returned.  Both the Old and New file specifiers can be either string or literals.

Examples:: `RENAME"TEST.BAS" TO "TESTER.BAS"` +
`RENAME A$ to B$` +
`RENAME A$ to "OLDFILE"`

==== DSEARCH

*Syntax* : `DSEARCH(` _file.ext:drive_ `)`

`DSEARCH` is a numeric function that is used to determine if a
specified file exists on the specified or default drive. The file id may be any valid String variable or literal. If the file does not exist a value of zero is returned, if the file does exist a value of -1 is returned.

Example:: `IF DSEARCH(A$) THEN KILL A$` +
`A=DSEARCH(DATAFILE.DAT:2)`

==== DRIVE

*Syntax* : DRIVE _<value>_

The `DRIVE` command is used to specify a default Disk Drive for Disk I/O commands and functions. The Value can be either a number or numeric expression. There is no run time error checking for the `DRIVE` command, so a value greater than 3 is allowed (useful for 5 Meg. Hard Disk users). The default drive number is used when ever a Disk I/O command does not specify a drive number.

Example:: `DRIVE 3` +
`DRIVE A`

[NOTE]
The first example would set the default drive to #3. The
second example would set the default drive to the number specified by the variable A.

==== VERIFY

*Syntax* : `VERIFY` _<ON/OFF>_

The `VERIFY` command is used to tell the system whether or not to verify (Read after Write) all write operations performed on the Disk System. The System normally leaves `VERIFY OFF` by default.

If `VERIFY` is enabled by the `VERIFY ON` command, all disk writes will take two disk revolutions to complete. One to write the sector and the next to read back the information written to verify that it was written correctly. It is a good practice to keep the verify option enabled to insure disk data integrity. However, it does take twice as long to write the same information on disk with `VERIFY ON` as it does to write it with `VERIFY OFF`.

Example: `VERIFY ON` +
`VERIFY OFF`

[NOTE]
The first example would turn disk verification on (enabled)
and the second example would be used to turn disk verification off (disabled).


==== DSKI$ & DSKO$

*Syntax* : `DSKI$ drive, track, sector, A$, B$` +
`DSKI$ drive, track, sector, BUF$`

The DSKI$ and DSKO$ conunands are used to perform Disk Input (DSKI$) and Output (DSKO$) without the use of the Disk Operating System. These conunands input and output directly to a sector (256 bytes) on a specified disk. The drive, track and sector values can be any numbers or variables, and specify where the disk I/O is to be performed. {cb} has two options for using these conunands. Since a sector is 256 bytes and string variables can only be a maximum of 255 bytes in length, two string variables are required to hold the contents of a single sector. Each of these variables is to be 128 bytes each. If the variable names specified in the command are not previously used in the program, {cb} will automatically create two consecutive variables of the required length. If the variable names were previously used in the program, they must be a minimum of 128 bytes each or an error will be declared. The second option is to use the {cb} variable BUF$ which is the 256 byte run-time I/O buffer. If BUF$ is used, it is the only variable that is to be specified.

Since direct disk I/O can easily destroy a disk file or the disk directory, you should be very careful when using these statements. Only an experienced progranuner who has a good working knowledge of the disk system should even attempt to use these commands.

Examples:: `DSKI$ 0,17,3,A$,B$` +
`DSKO$ 0,TK,SC,BUF$`

These commands may also use subscripted variables for the sector data storage, however, the data is stored in 256 consecut ive bytes starting at the first variable specified. When using a subscripted variable, only the first variable need be specif ied and must be dimmed for a length of 128 bytes or incorrect results will occur. For example if the array `A$` were to be used it would be dimmed something like `DIM A$(35, 128)`. This would be sufficient space for 36 blocks of 128 bytes each (18 sectors or 1 track ). The program to read a full track into the array would be something like the following:

[source, bbcbasic]
----
10 DIM A$(35,128)
20 FOR S=0 TO 17
30 DSKI $ 0,17,S+1,A$(S*2)
40 NEXT S
----

==== CLOADM & LOADM
 
*Syntax* : `CLOADM` _"file name",offset` +
`LOADM` _"file name",offset_

The `CLOADM` & `LOADM` commands are identical to the Color Basic `CLOADM` & `LOADM` commands. They allows you to load Machine Language programs from cassette tape (CLOADM) or DISK (LOADM) into memory.

The "file name" can be any valid string expression and the offset value is optional. If used, the offset value may be any valid numeric expression. The offset value is added to the load address of the progra~, that address is then used for the location in memory where the program will be stored.

Example:: `CLOADM "TEST",$1000` +
`LOADM NA$,OF`

==== CSAVEM & SAVEM

*Syntax* : `CSAVEM` _"file name",begin,end,exec._ +
`SAVEM` _"file name",begin,end,exec._

The CSAVEM & SAVEM commands are used to save a machine language program or file in memory to either tape (CSAVEM) or Disk (SAVEM). The "file name" can be any valid string expression or string variable. The begin, end and execution addresses of the file are required and may not be omitted. They can be any valid numeric expression or variable. {cb} does not check the validity of the addresses at run-time, it is up to the programmer to check for address validity (begin not greater than end).

Example::  `CSAVEM"TEST",$2000,$3000,$2000` +
`SAVEM NA$,BEGIN,END,BEGIN+l2`

<<<

=== I/O Functions

The following section will discuss the functions available for use with disk related I/O. All the functions listed will return a numeric value related to a particular disk file or drive. These functions can be used wherever a number or value is used in an expression.

==== FREE

*Syntax* : `FREE` _<drive #>_

The FREE function returns the number of available or free granuls on a specified disk drive. If no drive is specified, a default drive of 0 is used.

_Example_

[source, bbcbasic]
----
5 PRINT FREE(1)
10 IF FREE(2) > 10 THEN 100 ELSE 200
100 OPEN "O";#1,":2 DATA"
200 PRINT"LOW DISK SPACE ON DISK DRIVE #2"
----


==== LOC

*Syntax* : `LOC(` _#F_ `)`

The LOCation function returns the current number stored in a Random Access File buffer for a specified file number. If used on a sequential access file, it will always return a value of 0.

Example:: `100 PRINT @18,"RECORD #";LOC(1);" BEING PROCESSED"`


==== LOF

*Syntax* : `LOF(` _#F_ `)`

The LOF function returns the highest record number of the specified random access file. If used on a sequential access file, unspecified results will occur. This function can be useful to avoid accessing past the end of file which will cause an error. This value is also used for various types of sort functions and hashing access techniques.

_Example_

[source, bbcbasic]
----
100 FOR I=l TO LOF(l)
110 GET #1,I:REM READ RECORD OF FILE
120 NEXT I
130 REM NOW POSTITIONED AT END OF FILE
----

==== MKN$

*Syntax* : `MKN$(` _number/variable_ `)`

This function will convert a numeric variable or number into a 2 byte coded string for storage in a formatted or fielded disk file buffer. It is normally used in conjunction with a fielded variable so that numbers can be stored in a disk file, using a field length of 2 bytes to store any number up to 5 digits in length.

[source, bbcbasic]
----
5 A = 23456
10 LSET B$=MKN$(A)
----

==== CVN

*Syntax* : `CVN(` _string variable_ `)`

This function will convert a 2 byte coded string previously created by the MKN$ function back to a numerical representation.  It can be displayed directly or assigned to a numeric variable.

_Example_

[source, bbcbasic]
----
5 PRINT CVN(B$)
10 A = CVN(B$)
----

== Differences Between Cbasic-III And Color Basic Programs

Even though a {cb} program may be designed to perform the same function as a typical Color Basic program, it may appear to execute differently. For example:

[source, bbcbasic]
----
10 FOR I = 1 TO 10
20 PRINT I
30 NEXT
----

If the above program is run under Color Basic you would simply see it display the number from 1 thru 10 on the screen. It would then display an "OK" message and stop. The same program compiled under {cb} may appear to execute differently, even though it doesn't. If you watch the screen very carefully, and don't blink your eyes when executing the compiled version of the same version program. You will see that it will also display the numbers from 1 thru 10 on the screen, however, it disappears almost immediately after displaying the numbers. The next thing you see is the Color Basic message, just like you do when you first power on the computer.

One of the reasons for this is, {cb} produces pure Machine Language programs, and under some circumstances it modifies the configuration of the normal Color Basic operating system. If the program were simply allowed to return control back to the Color Basic Operating System, it may "appear" to work ok.

But, if you started to write a program or perform some disk operation, the system might crash, destroy a disk, or some other unpredictable results might occur. In order to avoid this situation the {cb} program forces the computer to do a "Cold Start" when it is finished. This may not be necessary in all cases, but, it is the safest and most reliable way to return control back to Color Basic.  Almost all good Machine Language programs, which modify the operation of the computer in any way will perform this type of "Cold Start" when the program is finished.

From looking at the previous example, it may appear that this is an un-necessary precaution. But, on the other hand, most programs will not be this simple, if they were, there really would be no reason to compile them into Machine Language programs. {cb}has a large variety of commands and functions that allow it to do many things besides straight forward Basic programs. It has the capacity to provide a complete Operating System environment for programs, not available in Color Basic. Normally these functions could only be performed by an experienced Machine Language Programmer. 

Things like Interrupt Handling and using the upper 32K of a 64K machine. You can easily and quickly control or manipulate Hardware Devices such as the X-PAD, DELUXE RS-232 Program PAK and various other devices available from third party vendors. In normal Color Basic operating these types of devices is slow and cumbersome. {cb}also provides you with an optional Hi-Resolution Text Display Package that is directly attached to your compiled program. With these types of advanced operations, you can not expect to be able to keep the Color Basic Operating System completely functional. Therefore it must "Cold Start" the system to insure that Color Basic is completely operational when the {cb} program is finished.

If you need to see the results of a programs display on the screen before the program exits back to Color Basic, use an INPUT statement just before the STOP or END Statement. This will allow you to see the display and simply hit the "enter" key when you are finished.

=== Remark Statements

With {cb} programs, the `REM`  or `'` statements do not affect the compiled program size or execution speed in any way. They do not produce any code within the compiled program. By using REMark statements generously, it will enable you to improve the internal documentation and readability of your program, without affecting it's performance. It pays to write well documented programs that can be understood and modified easily, either by yourself or others.

=== Graphic Statements

{cb} has the same Graphics Statements that are available in Extended Color Basic, and consequently {cb} uses many of the graphics subroutines available within the Extended Basic ROM.

Since {cb} uses the same machine language code to generate the same functions as Color Basic the actual time to draw or display the graphics is the same. However in a {cb} program, the same Graphics statement will execute about 4 times faster than Extended Color Basic. We probably could have made it much faster by rewriting the run-time graphics package but the cost i n memory would be tremendous, and the Graphics syntax would not be compatible or as extensive as Extended Color Basic. The reason that {cb} executes graphics faster than Color Basic is that the compiled program does not have to lookup the command and variable locations each time a graphics statment is executed, this is where the real speed increase comes from in {cb}.

When using Graphics statements in {cb}, if you use numeric constants for the x,y coordinates or parameters, the generated code will be shorter and execute s l ightly faster than using variables. This applies to the statements: `CIRCLE` , `LINE` , `PSET` , `PRESET` , `SCREEN` , `PMODE` , `COLOR` , `PAINT` , `PUT` and `GET`. This format will save from 8 to 20 bytes of code in the compiled program for each statement using this method. By making use of subroutines wherever possible for duplicated statements, you will also reduce a programs size significantly.

=== Using Subroutines

Since {cb} is a native compiler (generates actual machine code), each statement compiled will generate the equivalent machine code to perform that function. In many programs the same statement may be executed several times, especially in graphics programs. Each statement compiled will produce roughly the same amount of code, so even a single line which is used repeatedly in a program will produce a significantly larger program. If statements which are used repeatedly are made into subroutines and called with a `GOSUB` statement, the program size will be reduced significantly. A `GOSUB` statement only generates 3 bytes of code to call a subroutine, and to make a single statement or group of statements into a subroutine only requires that it be ended with a `RETURN` statement (1 byte of code). If this method is used to replace a single complex `IF` and/or `THEN`... `ELSE`... statement you could easily save up to 200-300 bytes of code for each occurence. A typical graphics or string statement using variables can use anywhere from 20 to 50 bytes for each occurance. So you can easily see how much memory space can be saved with little or no effect on program execution speed.

=== Data & Generate Statements

Many Color Basic programs will use `DATA` statements to hold a machine language program or subroutine and then read the data and poke it into memory somewhere. It then calls the program or subroutine using the `DEFUSR` and `USR` statements or the `EXEC` statement. While this type of format can be used in {cb} it will waste a tremendous amount of program space since the `DATA` uses almost twice the amount of memory required, and it will still occupy space in the program after the proram or subroutine is poked into memory. {cb} has a statement called `GEN` (generate) which allows machine language programs to be embedded directly within the compiled program. This also allows these routines to be called from within the program by simply using a `GOSUB` or `GOTO` statement. The subroutine can return control back to the program by simply ending it with a *RTS ($39)* op code. This also eliminates the problem of placing the program in a part of memory where it will not be disturbed as well as using the `READ` and `POKE` statements to get it into memory.

=== For/Next Loops & Timing

Many Color Basic prorarns use `FOR/NEXT` loops for delays and timing. Since {cb} will execute a straight `FOR/NEXT` loop almost 1000 times faster it is not practical to use it for delays and timing. For example: `FOR X=1 TO 1OOO:NEXT` this statement in Color Basic will take almost 2 seconds to complete, but in {cb} is will be less than the blink of an eye. To generate accurate or consistent time delays in {cb} it is suggested you use the TIMER function, which will count up in 1/60 of a second intervals.

_Example_

[source, bbcbasic]
----
10 TIMER=0
20 IF TIMER <120 THEN 20
----

This will produce a delay of 2 seconds, if you know how many seconds you want to del ay just multiply it by 60 and use that number in the `IF TIMER` statement. This format will also produce less code than the equivalent `FOR/NEXT` loop and will be much more accurate for timing and delays.

=== Get to know your Color Computer

If you have not had experience with the 6809's machine language, take the time to aquire some understanding of it. There are many good books and reference manuals available from Radio Shack. It is not absolutely necessary to have an understanding of machine language to use the {cb} compiler, in fact it was designed to be as compatible with the Color Basic interpreter as possible. This enables you to write and debug most programs using Color Basic, which is much easier than trying to debug machine language programs. However, many of the advanced features of {cb} can not be used in Color Basic. If you have a good understanding of how the machine works and operates, you will have much less difficulty using {cb} and its advanced features.

=== Debugging Compiled Programs

If your {cb} program compiles without errors, but does not perform as expected, chances are you made a logical programming error. Make sure that the Program and Data storage areas do not overlap. If variable storage is allocated in the upper 32K of RAM, did you use the `RAM64K` page# statement? Make sure there are no DISK buffers (#l-#9 vars) in the upper 32K.

_Does the {cb} program overlap or conflict with another program being called?_

The {cb} program listing provides you with some valuable information that can be used to find run-time errors in conjunction with the `TRACE` statement and a Monitor/Debugger program, like Cer-Comp's TRSMON System Monitor. The statement addresses on the listing can be used to set Breakpoints at the beginning of a specific program line. The Symbol table dump at the end of the listing shows variable memory locations, that can be examined with the Monitors memory examine and change function. With this information you can tell whether or not the program is running correctly up to the point where you examined the variables.

Read the Manual carefully, there is a great deal of information in this document which can make programming in {cb} easier for you. If {cb} is your first experience with a compiler, it would be wise to read this manual more than once. 

[TIP]
Many of the questions we get about programs are answered in the manual, so before you call or write to us with a question, check the manual, chances are the answer to your question is in here.

=== Errors During Compilation

When {cb} detects an error in the source program during compilation, the source line in error and a message describing the error will be displayed. The line immediately below the source line in error will have an "up-arrow" showing the approximate position of the error. Note that on long statement lines it may be more than one line below the last line to indicate that the error is on the second, third or fourth display line. This error locating arrow is about 95% accurate. When an error is detected the compiler will not process any further information on the line, even if it is a multiple statement line. So examine the rest of the line carefully for possible undetected errors. 

[WARNING]
If an error should occur during compilation, "DO NOT" attempt to execute the compiled program, as the program is incomplete and undetermined results will occur. Maybe even crash or wipe out a disk. 

=== Converting Color Basic Programs

==== Variable Initialization

Many Color Basic programs can be converted to {cb} compiled programs easily. However, in many cases the program will assume that all variable storage is cleared at run-time. In {cb} this is not the case, variables are not initialized automatically. This can cause very strange results when the compiled program is executed. If variable initialization is required in a program, it can be done by assignment statements: `A=0:B=0:A$=""` etc. This can take a lot of program code depending on how many variables are to be initialized. Another method can be used that will produce less program code and clear all variables to a `0` or `""` state. This method uses a `FOR/NEXT` loop and the `VARPTR` function. In the beginning of the program, use a variable name not used in the program and assign it a value of 0, then follow it with a `GOSUB` to a line # past the end of the program. 

Example:: `YY=0:GOSUB 9990`

For the last lines of the program write a `FOR/NEXT` loop using another previously unused variable name in the following form: 

Example: `FOR ZZ=VARPTR(YY) TO VARPTR(ZZ)-1` 

The final form of the initialization routines would look something like this: 

_Example_

[source, bbcbasic]
----
10 YY=0:GOSUB 9990
9990 FOR ZZ=VARPTR(YY) TO VARPTR(ZZ)-1
9995 POKE ZZ,0:NEXT
----

This is one of the easiest and most effective ways to initialize variables in a {cb} program.

==== Dimension Statements & Strings

Another area of confusion when converting Color Basic programs is String Variable arrays. In Color Basic a Dimensioned String array only has one element, `DIM A$(10)` , in its definition.  In Color Basic this means to allocate 10 different strings, `A(1) thru A(10)`. In {cb} it means to allocate 1 string 10 characters in length. The reason for this is to allow better control over variable storage allocation and eliminate the problems associated with "String Pools" and "Garbage Collection" at run-time. When you define a string array in {cb}, you must tell it the number of elements in the array and the length that is to be reserved for each string: `DIM(10,32)`. This would allocate space for 10 strings of 32 characters each. This can be changed easily when converting a Color Basic program, by using the Editor in {cb} to search for DIM statements and then use the *Line Edit* function to change it to the correct format. {cb} will also automatically allocate space for an array up to 10 elements without requiring it to be declared in a `DIM` statement.

[TIP]
Remember that each element is assigned only 32 bytes of space the same as a default string variable.

==== String Variables

{cb} will normall y allocate 32 bytes of storage for a string variable unless it is decaired in a `DIM` statement. In some Color Basic programs you may see an assignment statement in which the string being assigned is longer than 32 characters. In these cases you will have to use the `DIM` statement in {cb} to allocate enough space for the string variable or it will be truncated to 32 characters. This can cause an *FC* Function Call error in a program when the string is used as part of a DRAW or PLAY statement. Use the `TRACE` function to locate the line # that is causing the problem.

_Example 1_

[source, bbcbasic]
----
10 A$ ="BM10,10;C2;U8R6F2D2L8BR8D2G2L6BR12U8R8D8"
20 DRAW A$
----

_Example 2_

[source, bbcbasic]
----
5 DIM A$(50)
10 A$="BM10,10;C2;U8R6F2D2L8BR8D2G2L6BR12U8R8D8"
20 DRAW A$
----

[NOTE]
The first example would cause an *FC* error when the program is run since the assignment would only move the first 32 characters to the variable  In the second example the variable A$ was first assigned 50 characters of space in the DIM statement before being assigned the string. It would execute correctly.

==== Graphics Get & Put Arrays

Most of the time Color Basic programs that use t he Graphics `GET` & `PUT` statements will define an array large enough for {cb} to use. Sometimes a program will use a different method than the one mentioned in the {ecb} manual to calculate the size of an array for a `GET` or `PUT`. In these cases the array may not be large enough for {cb} to use. This can produce a *FC* Function Call error at run-time. If you encounter this problem refer to the {cb} manual secti on on `GET` & `PUT`  statements to check the dimension calculations. Also use the `TRACE` function to locate the line # causing the error.

== Language Summary

=== Assignment Statements

[cols=5,frame=none,grid=none]
|===
|LET      |POKE |DPOKE|DATA |READ 
|RESTORE  |LSET |RSET |SWITCH |
|===

=== Control Statements

[cols=5,frame=none,grid=none]
|===
|EXEC           |CALL         |RUN          |FOR          |NEXT
|STEP           |GOTO         |GO           |SUB          |RETURN 
|IF /THEN/ELSE  |STOP         |END          |ON/GOTO      |ON/GOSUB 
|ON ERROR GOTO  |ON BRK GOTO  |ON OVR GOTO  |ON NOVR GOTO | ON RESET GOTO
|STACK          |CHAIN        |             |             |
|===

=== Interrupt Control Statements

[cols=5,frame=none,grid=none]
|===
|ON KBDlRQ GOTO   |ON TMRIRO GOTO   |ON SERIRQ GOTO | ON IRQ GOTO   | ON NMI GOTO
|ON FIRQ GOTO     |ON SWI GOTO      |RETI           | IRQ on/off    | IRQ = mask 
|SWI              |IRO SIMULATE     | FIRQ SIMULATE | NMI SIMULATE  | 
|===

=== Input/Output Statements

[cols=5,frame=none,grid=none]
|===
|OPEN     |INPUT        |LINE INPUT     |PRINT    |PRINT @
|WRITE    |CLOSE        |FIELD          |GET      |PUT 
|RESTORE  |KILL         |RENAME         |DSKI$    |DSKO$ 
|VERIFY   |DRIVE        |CLOADM         |LOADM    |CSAVEM
|SAVEM    |GETCHAR      |PUTCHAR        |BRATE    |PRATE 
|DSEARCH  |AUDIO on/off |MOTOR on/off   |         |
|===

=== Extended Memory Statements

[cols=5,frame=none,grid=none]
|===
|RAM64K page# | RAM on/off  |LPEEIC   |LPOKE  |DLPEEK
|DLPOKE       | LP COPY     |         |       |
|===


=== Hi Resolution Screen Statements

[cols=5,frame=none,grid=none]
|===
|HIRES(8 modes) | WIDTH     | LOCATE  | ATTR  | HSTATUS
|===

=== Compiler Directives

[cols=5,frame=none,grid=none]
|===
|BASE   |ORG    |GEN      |END    |DIM
|REM    |DPSET  | MODULE  |PCLEAR |PAUSE on/off 
|CCLINK |UNLINK |         |       |
|===

=== Numeric Functions

[cols=5,frame=none,grid=none]
|===
|ABS    |POS    |POS@   | RND     |PEEK
|DPEEK  |TAB    |ASC    | LEN     | INSTR 
|VAL    |ERR    |EOF    | SWAP    | LOF 
|LOC    |FREE   |CVN    |VARPTR   |JOYSTK 
|BUTTON |INKEY  |TIMER  |OVEREM   | SGN 
|ERL    |INT    |       |         |
|===

=== String Functions

[cols=5,frame=none,grid=none]
|===
|CHR$     |LEFT$    | RIGHTS    | MID$     |STR$
|TRM$     |STRING$  | MKN$      |INKEY$    |BUF$
|HEX$     |SWITCH$  | SWAP$     |          |
|===


=== Sound and Graphics Statements

[cols=5,frame=none,grid=none]
|===
| PLAY    |SOUND     | (H)ClRCLE   | (H)COLOR    |(H)CLS
|(H)DRAW  |(H)GET    | (H)PUT      | (H)LINE     |(H)PAINT
|PCLS     | PCOPY    | PMOOE       |PSET         |PRESET 
|(H)RESET | (H)SCREEN|(H)SET       |(H)POINT     |PPOINT 
|HMODE    |BORDER    |HPRINT       |HBUFF        | PALETTE 
|RGB      |CMP       |             |             | 
|===


=== Arithemetic Operators 
[width="80%",align="center"]
[cols="20,80"frame=none,grid=none]
|===
| +   | Add
| =   | Subtract 
| /   | Divide
| *   | Multiply
| -   | Negate
|===



=== Logical Operators 
[width="80%",align="center"]
[cols="20,80"frame=none,grid=none]
|===
| &   | Logical AND
| !   | Logical OR
| %   | Logical XOR
| #   | LOGICAL NOT
| +   | Concatenate String
|===

=== Relational Operators 
[width="80%",align="center"]
[cols="20,80"frame=none,grid=none]
|===
| < , > , =   | Greater Than, Less Than, Equal
| {lte} , {gte}     | Less Equal, Greater Equal
| <>          | Not Equal
| AND / OR    | 
|===




== Run-Time Error Codes

One of the following codes will be generated if an error occurs during the execution of a compiled program. The `ERR` or `ERNO` function will return the most recent error generated, provided `ON ERROR` trapping is active. A determination can be made by the program, based on the error condition, to attempt correcting the error, abort the program or whatever the programmer decides.

If `ON ERROR` trapping is disabled, a normal Basic error message will be displayed and control will then be returned to Color Basic. At this point there are basically two options available. Either to press the Reset button to Cold Start the computer or re-execute the program with an `EXEC` statement. If for some reason the compiled program was corrupted, re-execution may cause the computer to crash or some other unpredictable results may occur. For this reason it is recommended that a `POKE&H71,0` be performed and the Reset button pressed to insure that the computer is cleared to its normal state.

[width="80%",align="center"]
[cols="20,80"frame=none,grid=none]
|===
|CODE| MEANING
|01 |Next Without For, should not occur
|02 |Syntax error, cause unknown
|03 |Return Without, should not occur
|04 |Out of data in READ statement
|05 |Illegal function call, use TRACE to locate line#
|06 |Multiply overflow, results exceeded +32767 to -32768
|07 |Out of Memory, Illegal procedure call
|08 |Undefinde line, should not occur
|09 |Bad Subscript, should not occur
|10 |Attempt to Redimension an array, should not occur
|11 |Divide by zero attempted
|12 |Illegal Direct Statement, should not occur
|13 |Variable and data type mismatch
|14 |Out of String Space, should not occur
|15 |String too long, should not occur
|16 |String formula too complex, should not occur
|17 |Cannot continue, should not occur
|18 |Bad file data
|19 |File already open, disk or tape
|20 |Bad device number
|21 |Input or Output device error (hardware ?)
|22 |File Mode error, attempted input from output device, etc.
|23 |File not open for I/O
|24 |Attempted to input more data than a file contained.
|25 |Direct Statement, should not occur
|26 |Undefined function attempted
|27 |File does not exist (disk)
|28 |Bad random access disk record number.
|29 |Disk is full, no more room to write
|31 |Disk is write protected on attempted write
|32 |Bad file name
|33 |Disk file structure is corrupted.
|39 |Hires Graphics Error
|40 |Hires Print Error
|===

== Hi-Resolution Text Package

The Hi Resolution Text Package is designed to improve the standard 32*16 and `WIDTH 40` `WIDTH 80` Screen displays. The program is fully integrated into the compiled Basic program by using the `HIRES` statement. It also allows you to switch back and forth between the Hi-Res format and the Standard 32 by 16 format for complete compatibility in almost all situations. The format of the display when the compiled program is first executed de faults to 80 characters by 24 lines. This can be changed to 32, 40, or 64 characters in either 192 or 225 Resolution modes thru the use of control codes. The package also includes other control code functions which add an extensive amount of flexability to the display. Some of them include: Reverse Screen, Reverse character, Underline character, Double Size characters, Erase to end of line, Erase to end of screen, Clear Screen, Home Cursor, Bell tone, and more. All of these features are controlled thru the use of control code characters sent via the CHR$(n) Basic statement or thru Machine language routines. The following is a list of Control codes recognized by the program and the function that it performs.

[width="80%",align="center"]
[cols="20,80"frame=none,grid=none]
|=== 
|CHR$(n) |Function

|1 |Display Black characters on a White background (Default)
|2 |Display White characters on Black background.
|6 |Switch between Blinking & Non-Blinking Cursor
|7 |Sound Bell tone.
|8 |Backspace cursor one character position.
|9 |Advance cursor one character position.
|10 |Move cursor down one line (Scroll if at bottom).
|11 |Initiate X,Y cursor position function.
|12 |Clear screen.
|13 |Move cursor to begin of line & move down 1 line.
|14 |Turns character Underline off (default).
|15 |Turns character Underline on.
|16 |Home cursor to position #0 on the screen (top left).
|17 |Turns Destructive Cursor on.
|16 |Turns Destructive Cursor off (default).
|19 |Turns Space character Underline On (Default)
|20 |Turns Space character Underline Off
|21 |Erase from cursor to the end of line.
|22 |Erase from cursor to the end of screen.
|23 |Turn Reverse character mode off (Default).
|24 |Turn Reverse character mode on.
|25 |Save current cursor position.
|26 |Restore cursor to previously saved position.
|27 |Change chars/line, or Auto key repeat
|28 |Change display to Monochrome or Color mode.
|29 |Switch Screen format to Hi-Res or Standard 32*16.
|30 |Turns double size characters off (default).
|31 |Turns double size characters on.
|===

=== Control Code Use

All of the screen control functions will be used with the Basic statement `PRINT CHR$(` _n_ `)` to perform the task. For example, to clear the screen use the Basic statement `PRINT CHR$(12)` 

[NOTE]
There are several control functions which are not completed with just a single character code. The first one, (11), is used for X,Y cursor positioning and the second one , (27), has two functions depending on the value of the character immediately following it. The X,Y cursor position function allows the cursor to be positioned to any location on the screen with a minimum of effort. This can be useful for screen mapping & information updating.

[TIP]
This is similar to the Basic `PRINT@` function. Instead of using a single number for the location, a column position and line number are used . These values must immediately follow the X,Y control code. A column value of 0 to the current number of characters per line may be used (51 is the default). The line number must then follow with a value from 0 to 23. For example, to position the cursor to the middle of the screen and print the word "HELP", see the example below.

Example::  `PRINT CHR$(11);CHR$(23);CHR$(11);"HELP"` kbd:[ENTER]

This would print the word "HELP" starting at column 23 on line 11. Notice that a `;` must be used between each character so that other characters are not sent in between the column, line #, and print data for the command to work correctly.

=== "Escape" Character Sequence Commands

The _Escape_ code `CHR$(27)` is used for three different functions depending upon the value of the character following it:

* The number of lines on the Hi-Res Screen to be protected
* The number of characters per line to be displayed on the Hi-Res Screen
* Clearing several of the Special functions options with a single command

=== Changing Characters per line

The Hi-Res Screen package allows the user to set the number of characters displayed per line on the Hi-Res Text Screen. This can be varied from 32 to 80 characters per line in defined steps.  The Hi-Res screen defaults to a 80 characters across by 24 lines in 225 Resolution at program startup time, but can be changed to one of 8 different formats. The following characters correspond to the number of display characters per line selected when used following the "Escape" code:

[width="80%",align="center"]
[cols="10,40,10,40"]
|===
|1 |32 (192) |2 |40 (192)
|3 |64 (192) |4 |80 (192)
|5 |32 (225) |6 |40 (225)
|7 |64 (225) |8 |80 (225) *
|===

_*_ = Default

_Examples_
[width="80%",align="center"]
[cols="50,50"]
|===
| `PRINT CHR$(27);"5"` kbd:[ENTER]   | Set width to 32, 225 Res.
| `PRINT CHR$(27),"64"` kbd:[ENTER]   | Set width to 64, 192 Res.
|===

=== Clearing Special Functions

There is a special function code used to reset most of the special functions in the HI-Res package. The functions which are reset to the default conditions are:

* Reverse Display (2)
* Underline (15)
* Reverse character mode (24)
* Double Size characters (31)
* Destructive Cursor (18)
* Protected lines (27) 

All of these functions can be reset by the single command: 

`PRINT CHR$(27);"0"`

This can be useful for clearing display options used during a program that has been interrupted while some of these functions were in use, or at the end of a program using them.


=== Changing Screen Formats

This function allows the user to switch screen formats back and forth between the Normal 32*16 screen and the Hi-Res screen. When in the Standard 32 by 16 screen all Hi-Res control functions will be ignored except the `CHR$(28)` which is used to return you back into the Hi-Res Screen format. This function toggles or flips back and forth between formats each time it is entered.

=== Changing Monochrome or Color modes

This command allows the user to select whether or not to supress the color display thru a single control character. The screen comes up in Monochrome mode by default and be changed by sending a `CHR$(28)` . Each time it is send, the screen flips between Mono & Color mode, the Basic command would be `PRINT CHR$ (28)`

=== Character Highlighting Functions

The majority of the control functions supported consist of a single control code and can easily be used in a Basic program.

Three of the functions control how the characters will be displayed on the screen until they are turned off. They are: 

* Underline CHR$(15)
* Reverse characters CHR$(24)
* Double size characters CHR$(31) 

Once these functions are enabled, each character displayed will be affected by the active functions. Any combination of the three or all three may be enabled at the same time. They may also be reset at any time. The Reverse character effect can also be obtained by adding a value of 128 to any normal ASCII printable code. For example, to highlight a single character just add 128 to the letter using the format: 

`PRINT CHR$(ASC("Z")+128)`

The Destructive cursor function allows you to tell the program whether or not to erase the character at the current cursor location. This is normally on by default. Some screen editing programs require it to be off to function correctly, while others require it to be on, so characters are erased during backspace operations. For these reasons we allow it to be changed.

[TIP]
The Reverse screen function also allows for special effects, or just personal preference for the screen display.

=== Additional Functions

Additional functions have been added to allow more flexibility in using Hi-Res. 

* blinking and non-blinking cursor toggle `CHR$(6)`
* Underline SPACE on `CHR$(19)` & underline SPACE off  `CHR$(20)`

[NOTE]
These remain in effect until turned off or switched by their counterpart code.

=== Effects On Basic Screen Commands

This package was designed to be as compatible and convenient to use as possible, so normal operations with {cb} programs would be affected as little as possible. Since some Basic programs use commands that affect the screen display, we have tried to make them as compatible as possible with the new screen format. Unfortunately, this may not be 100% compatible but should be close enough so the programs will still run without any major problems. If problems do arise, you can always switch back to the standard screen format for those functions, and then back to the Hi-Res format with a simple function command.

One of the most common screen commands is `CLS`, the clear screen command. With the Hi Resolution package in the compiled program, this command only clears the screen in normal video (black characters on a white background). If a value follows the command, it will clear the standard 16*32 Text screen to that color.

The second most used screen command is the `PRINT@` function . Under normal system operation this value may not exceed a value of 511, or an error will occur. You only have 32 character positions available per line by 16 lines, thus 0 to 511 is the range. When using the Hi Resolution screen package any value is allowed and will be adjusted according to the number of characters displayed per line. For example, if you printed at column 68 in the 40 character mode, it would display on line 2, column 28. If you did the same thing in 64 character mode, it would display on line 2, column 4. If you would like to have compatibility with the old screen format, just reprogram the number of characters per line to 32. This is accomplished by the statement:

`PRINT CHR$(27);"1"`


When in this mode, all `PRINT@ `screen formatting should be almost identical to the original format.

== Sample Programs

=== Disk Directory 

[source, bbcbasic]
----
0010 REM This is a demonstration program that shows
0020 REM how to use the BASE & DIM statements to map
0030 REM out an area of memory for reading and analyzing
0040 REM a disk directory using DSKI$. Since the variable
0050 REM arrays NA$ and EX$ are setup to map out the DSKI$
0060 REM variables A$ & B$. By using this method of re-mapping
0070 REM variables, extracting information is very fast
0080 REM since extensive string manipulation is not necessary.
0090 REM This method of variable mapping must be used any
0100 REM time the DSKI$ function is used to read mixed
0110 REM binary and ASCII information from disk. The reason
0120 REM for this, is string functions use a 00 as an end
0130 REM of string marker for strings shorter than the
0140 REM defined length. Thus when mixed ASCII & binary
0150 REM data are read using DSKI$, string functions will
0160 REM not allow access to any of the information in the
0170 REM string variable past the first 00 encountered.
0180 REM
0190 BASE=$5000 : REM start variable space at $5000
0200 DIM A$(128),B$(128): REM variables for DSKI$
0210 BASE=$5000 : REM put next variable at same place in memory
0220 DIM NA$(7,32) : REM map directory names every 32 bytes 0-7
0230 BASE=$5008 : REM map Extensions at name + 8 for each entry
0240 DIM EX$(7,32) : REM map Extensions every 32 bytes 0-7
0250 BASE=0 : REMrestore variables allocation to normal
0260 CLS:INPUT "DRIVE TO ANALYZE";D
0270 FOR S=3 TO 11: REM read sectors 3 thru 11 of directory track
0280 DSKI$ D,17,S,A$,B$ : REM read sector on track 17
0290 FOR L=0 TO 7:REM loop for 8 entries per sectory
0300 IF PEEK(VARPTR(NA$(L)))=$FF THEN 330:REM empty entry
0305 PRINT LEFT$(NA$(L),8);"." ;
0310 PRINT LEFT$(EX$(L),3),PEEK(VARPTR(NA$(L))+ll),
0320 IF PEEK(VARPTR(NA$(L))+12)=0 THEN PRINT "B" ELSE PRINT "A"
0330 NEXT L,S : REM loop for 8 entries & all sectors
0340 INPUT A:GOTO 260
----

<<< 
=== Disk Copy

[source, bbcbasic]
----
0001 OPT N: REM Option for no listing generated
0002 REM This example program demonstrates how to use the
0003 REM DSKI$ & DISKO$ with a string array to copy the
0004 REM contents of a disk to another disk. The destination
0005 REM disk must have been previously formatted. It is
0006 REM equivalent to having a "BACKUP" command .
0007 REM The program uses a string array to store the entire
0008 REM contents of a disk track for each read/write sequence.
0009 REM You could use the BASE & DIM statements to put the
0010 REM track buffer array anywhere in memory that doesn't
0011 REM cause a conflict.
0012 REM 
0015 DIM A$(36,128):REM Setup string ARRAY for Track buffer
0020 CLS:INPUT "DRIVE TO COPY FROM AND TO";CF,CT
0030 FOR T=0 TO 34 : REM Loop for all 35 tracks
0040 FOR S=0 TO 34 STEP 2: REM loop for 1-18
0050 DSKI$CF,T,(S/2)+1,A$(S),A$(S+1): REM read sector into array
0060 NEXT S
0070 FOR S=0 TO 34 STEP 2 : REM loop for sectors 1-18 write(track)
0080 DSKO$CT,T,(S/2)+1,A$(S),A$(S+1): REM write sector from array
0090 NEXT S,T: REM Next Sector & Track
0100 INPUT "COPY COMPLETE, ANOTHER COPY Y/N";A$
0110 IF A$=" N" THEN END ELSE RUN
----

<<< 
=== Disk Menu

[source, bbcbasic]
----
0010 ORG = $6000: HIRES : REM Include Hires Text package
0013 PRINT CHR$(27);"5" ; :REM SCREEN MODE 32 CHARS/225 RES
0015 POKE $FFD9,0 : REM HIGH SPEED
0020 BASE= $600 : DIM A$(128),B$(128): REM variables for DSKI$
0040 BASE= $600 : DIM NA$(7,32) : REM dir names every 32 bytes 0-7
0060 BASE= $608 : DIM EX$(7,32) : REM map .ext name+8 bytes 0-7
0080 BASE=O : REM restore variables allocation to normal
0090 DIM FI$(68,12) : REM array for all file names possible
0091 CLS
0092 PRINT" MENU MASTER PROGRAM" : PRINT
0100 PRINT "T - TEXTPRO3 C - CBASIC3"
0110 PRINT "E - EDTASM3 D - DPIII+"
0111 PRINT "M MONIIIA I - LASER "
0112 PRINT "S - SOURCE Q - QUIT "
0113 PRINT "L - DISKLOOK Q - QUIT "
0115 PRINT
0120 INPUT "DRIVE # OR COMMAND KEY ";C$
0125 IF C$="" THEN 091
0130 C=INSTR("TCEDMISLQ",C$)
0140 IF C=0 THEN D=VAL(C$) :GOTO 200
0150 ON C GOTO 160,170,180,190,191,192,193,194,195
0155 GOTO 91
0160 CHAIN"TEXTPR03.BIN:2"
0170 CHAIN"CBASIC3.BIN:2"
0180 CHAIN"EDTASM3.BIN:2"
0190 CHAIN"DPIII+.BIN:2"
0191 CHAIN"MONIIIA.BIN:2"
0192 CHAIN"LASER.BIN : 2"
0193 CHAIN"SOURCE3.BIN : 2"
0194 CHAIN"DISKLOOK:2"
0195 PRINT"EXITING PROGRAM BACK TO SYSTEM"
0196 POKE$71,0:POKE$FFD8,0:EXEC DPEEK($FFFE):END
0200 FOR I= 0 TO 68 : FI$(I)="":NEXT: I= 1
0205 DRIVE D
0210 FOR S=3 TO 11: ' read sectors 3 thru 11 of directory track
0220 DSKI$ D,17,S,A$,B$ : ' read sector on track 17
0230 FOR L=0 TO 7:' loop for 8 entries per sectory
0240 PK=PEEK(VARPTR(NA$(L)))
0250 IF PK=$FF OR PK=0 THEN 290:' empty entry
0260 IF DPEEK(VARPTR(NA$(L))+11)<>$200 THEN 290 : 'NOT BINARY
0270 FI$(I)= LEFT$(NA$(L),8)+"."+LEFT$(EX$(L),3)
0280 I= I+1 :'NEXT ARRAY ENTRY
0290 NEXT L,S : ' loop for 8 entries & all sectors
0300 IF I = 1 THEN RUN : ' NO EXECUTABLE FILES
0310 FOR F = 1 TO I - 1
0320 PRINT F;"-"; FI$(F), : 'display executable binary files
0330 NEXT: PRINT:PRINT
0340 INPUT"ENTER NUMBER OF FILE TO EXECUTE";F
0345 IF ((F>=I) OR (F<=0)) THEN 360
0350 PRINT "LOADING " ; FI$(F):CHAIN FI$(F)
0360 RUN
----

<<<
===  Graphics Print

[source, bbcbasic]
----
0010 OPT S,N
0020 ORG=$6000
0030 MODULE
0040 BASE=$0600 : REM start variable space at $5000
0050 DIM A$(128),B$(128): REMvariables for DSKI$
0060 BASE=$0600 : REM put next variable at same place in memory
0070 DIM NA$(7,32) : REM map directory names every 32 bytes 0-7
0080 BASE=$0608 : REM map Extensions at name + 8 for each entry
0090 DIM EX$(7,32) : REM map extensions every 32 bytes 0-7
0100 BASE=0 : REMrestore variables allocation to normal
0110 DIM FI$(68,12)
0120 RAM64K $30
0130 ON ERROR GOTO 660
0135 MODE=3:FG=0:BG=63
0140 PRATE=9600
0145 REM*****************************************
0146 REM* SET GRAPHICS MODE & DISPLAY           *
0147 REM*****************************************
0150 STACK=$6000:HMODE MODE
0160 PALETTE 0,FG : PALETTE 1,BG:PALETTE 8,FG:PALETTE 9,BG
0170 BORDER BF: TIMER=0:IRQ OFF
0180 IF TIMER<120 THEN 180 ELSE HMODE 0
0185 REM*****************************************
0186 REM* MAIN MENU PROMPT & INPUT              *
0187 REM*****************************************
0190 CLS:PRINT "pRINT, lOAD, sAVE, gRAPHICS"
0200 INPUT "mODE, dIRECTORY OR eXIT";A$
0210 IF A$="" THEN RAM64K 255:END
0220 A=INSTR("PLSGMD",A$): IF A=0 THEN RAM64K 255 END
0230 ON A GOSUB 250,430,520,150,710,790
0240 GOTO 140
0245 REM******************************************
0246 REM* LASER LINE6 GRAPHICS SCREEN DUMP       *
0247 REM******************************************
0250 INPUT "ENTER RESOLUTION 75, 100, 150, 300 ";RE$
0260 INPUT "DO FORM FEED WHEN DONE (Y/N)";FF$
0270 INPUT "START POSITION 0 OR 1 ";SP$
0280 HMODE MO
0290 MODE$=CHR$(27)+"*t"+RE$+"R"
0300 START$=CHR$(27)+"*r"+SP$+"A"
0305 IF(MODE=1)OR(MODE=3)THEN TW=80:TW$="080" GOTO 310
0306 TW=l60:TW$="160"
0310 TRANSFER$=CHR$(27)+"*b"+TW$+"W"
0320 AD=$8000: REMGRAPHICS IN 8000-FFOO
0330 IF SP$<>"0" THEN PRINT #-2,CHR$(10)
0340 PRINT #-2,MODE$;START$;:REMSEND MODE & START CMOS
0350 FOR LINE = 0 TO 191
0360 FOR DEPTH = 1 TO 2
0370 PRINT #-2,TRANSFER$;:REM SEND TRANSFER CMD
0380 FOR COL = 0 TO TW-1
0390 PUTCHAR #-2,PEEK(AD+COL):NEXT COL,DEPTH
0400 AD=AD+TW:NEXT LINE
0410 PRINT #-2,CHR$(27);"*rB";
0415 IF FF$="Y" THEN PRINT #-2,CHR$(12);
0420 RETURN
0425 REM*******************************************
0430 REM* LOAD GRAPHICS PAGE                      *
0431 REM*******************************************
0440 INPUT "ENTER NAME & DRIVE TO LOAD";FI$
0450 OPEN"R",1,FI$,256
0460 HMODE MO
0465 Y =LOF(1):IF Y>30720 THEN Y=30720
0466 CLOSE #1:OPEN "I",1,FI$
0470 FOR X=$8000 TO X+Y STEP 1
0490 GETCHAR #1,A
0500 POKE X,A : NEXT X
0510 CLOSE #l:RETURN
0515 REM*******************************************
0520 REM* SAVE GRAPHICS PAGE                      *
0521 REM*******************************************
0560 IF MODE AND 1 THEN Y =$BFFF ELSE Y = $F7FF
0590 INPUT "ENTER FILE NAME & DRIVE";FI$
0600 OPEN"O",#1,FI$
0610 FOR X=$8000 TO Y STEP 1
0620 PUTCHAR #1,PEEK(X)
0630 NEXT X
0640 CLOSE #1
0650 RETURN
0655 REM********************************************
0660 REM* ERROR HANDLER                            *
0661 REM********************************************
0670 HMODE 0
0680 PRINT "ERROR #";ERR;" IN LINE #";ERL
0690 INPUT "PRESS ENTER TO RESTART";A$
0700 GOTO 120
0701 REM********************************************
0710 REM* SET GRAPHICS MODE                        *
0711 REM********************************************
0720 HMODE MO
0730 GETCHAR #0,A
0740 IF A=8 THEN MODE = MODE -1
0750 IF A=9 THEN MODE = MODE +1
0760 IF MODE <0 THEN MODE=4
0770 IF MODE >4 THEN MODE= 0
0780 IF A=13 THEN RETURN ELSE 720
0781 REM*******************************************
0790 REM* DIRECTORY DISPLAY                       *
0791 REM*******************************************
0800 CLS:INPUT "DIRECTORY DRIVE #";C$
0810 IF C$="" THEN RETURN
0820 D=VAL(C$)
0830 FOR I = 0 TO 68 : FI$(I)="":NEXT: I = 1
0840 DRIVE D
0850 FOR S=3 TO 11: REM read sectors 3 thru 11 of directory track
0860 DSKI$ D,17,S,A$,B$ : REM read sector on track 17
0870 FOR L=0 TO 7:REM loop for 8 entries per sectory
0880 PK=PEEK(VARPTR(NA$(L)))
0890 IF PK=$FF OR PK=O THEN 920 : REM empty entry
0900 FI$(I)= LEFT$(NA$(L),8)+" . "+LEFT$(EX$(L),3)
0910 I= I+1 :REMNEXT ARRAY ENTRY
0920 NEXT L,S: REM loop for 8 entries & all sectors
0930 IF I=1 THEN 970:REM NO ENTRIES
0940 FOR F = 1 TO I - 1
0950 PRINT F;"-"; FI$(F),
0960 NEXT : PRINT
0970 INPUT"PRESS ENTER TO RETURN TO MENU";F$
0980 RETURN
----
































